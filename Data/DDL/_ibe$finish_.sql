

/* Check constraints definition */

ALTER TABLE UI$BLOCK_PARAM ADD CONSTRAINT CHK1_UI$BLOCK_PARAM CHECK ((source_child is null and source_param is null) or (source_child is not null and source_param is not null));
ALTER TABLE UI$FORM_CHILD_PARAM ADD CONSTRAINT CHK1_UI$FORM_CHILD_PARAM CHECK ((source_param is null and source_child is null) or (source_param is not null and source_child is not null));
ALTER TABLE UI$BLOCK_PARAM ADD CONSTRAINT CHK2_UI$BLOCK_PARAM CHECK ((index_in_key > 0) and (index_in_parent > 0) and (index_in_name > 0)
);
ALTER TABLE UI$BLOCK_PARAM ADD CONSTRAINT CHK3_UI$BLOCK_PARAM CHECK (param_direction='field' or call_order_num is not null
);
ALTER TABLE UI$MENU_ITEM ADD CONSTRAINT CHK1_UI$MENU_ITEM CHECK (item_type <> 'block' or block is not null);
ALTER TABLE UI$FORM_PANEL ADD CONSTRAINT CHK1_UI$FORM_PANEL CHECK (index_on_parent > 0);
ALTER TABLE UI$BLOCK_REF_PARAM ADD CONSTRAINT CHK1_UI$BLOCK_REF_PARAM CHECK (order_num > 0);


/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE UI$BLOCK_REF_PARAM ADD CONSTRAINT UNQ1_UI$BLOCK_REF_PARAM UNIQUE (REF, "BLOCK", ORDER_NUM);
ALTER TABLE UI$DEFAULT_ACTION ADD CONSTRAINT UNQ1_UI$DEFAULT_ACTION UNIQUE (ORDER_NUM);
ALTER TABLE UI$PROCEDURE ADD CONSTRAINT UNQ1_UI$PROCEDURE UNIQUE (IS_GRID_FOR_TABLE);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE IBE$PARAMS_HISTORY ADD PRIMARY KEY (IBE$PH_PROCEDURE_NAME);
ALTER TABLE IBE$VERSION_HISTORY ADD PRIMARY KEY (IBE$VH_ID);
ALTER TABLE UI$ACTION_BIND ADD CONSTRAINT PK_UI$ACTION_BIND PRIMARY KEY ("ACTION", PARAM, "BLOCK");
ALTER TABLE UI$ACTION_STYLE ADD CONSTRAINT PK_UI$ACTION_STYLE PRIMARY KEY (ID);
ALTER TABLE UI$BLOCK ADD CONSTRAINT PK_UI$BLOCK PRIMARY KEY (ID);
ALTER TABLE UI$BLOCK_ACTION ADD CONSTRAINT PK_UI$BLOCK_ACTION PRIMARY KEY (ID, "BLOCK");
ALTER TABLE UI$BLOCK_PARAM ADD CONSTRAINT PK_UI$PROCEDURE_PARAM PRIMARY KEY ("BLOCK", PARAM);
ALTER TABLE UI$BLOCK_REF ADD CONSTRAINT PK_UI$BLOCK_REF PRIMARY KEY (ID, "BLOCK");
ALTER TABLE UI$BLOCK_REF_BIND ADD CONSTRAINT PK_UI$BLOCK_REF_BIND PRIMARY KEY (REF, "BLOCK", DESTINATION_PARAM);
ALTER TABLE UI$BLOCK_REF_PARAM ADD CONSTRAINT PK_UI$BLOCK_REF_PARAM PRIMARY KEY (REF, "BLOCK", PARAM);
ALTER TABLE UI$BLOCK_TYPE ADD CONSTRAINT PK_UI$BLOCK_TYPE PRIMARY KEY (ID);
ALTER TABLE UI$DATA_TYPE ADD CONSTRAINT PK_UI$DATA_TYPE PRIMARY KEY (ID);
ALTER TABLE UI$DEFAULT_ACTION ADD CONSTRAINT PK_UI$DEFAULT_ACTION PRIMARY KEY (ID);
ALTER TABLE UI$FIELD_TYPE_FB ADD CONSTRAINT PK_UI$FIELD_TYPE_FB PRIMARY KEY (FB_TYPE_ID, DATA_TYPE);
ALTER TABLE UI$FORM ADD CONSTRAINT PK_UI$BLOCK_CONTAINER PRIMARY KEY (ID);
ALTER TABLE UI$FORM_CHILD ADD CONSTRAINT PK_UI$FORM_CHILD PRIMARY KEY (ID, FORM, "BLOCK");
ALTER TABLE UI$FORM_CHILD_PARAM ADD PRIMARY KEY (FORM_CHILD, PARAM);
ALTER TABLE UI$FORM_CHILD_REF_BIND ADD CONSTRAINT PK_UI$FORM_CHILD_REF_BIND PRIMARY KEY (FORM_CHILD, REF, DESTINATION_PARAM);
ALTER TABLE UI$FORM_PANEL ADD CONSTRAINT PK_UI$FORM_PANEL PRIMARY KEY (ID, FORM);
ALTER TABLE UI$GRID_STYLE ADD CONSTRAINT PK_UI$GRID_STYLE PRIMARY KEY (ID);
ALTER TABLE UI$MENU_ITEM ADD CONSTRAINT PK_UI$MENU_ITEM PRIMARY KEY (ID);
ALTER TABLE UI$MENU_ITEM_TYPE ADD CONSTRAINT PK_UI$ITEM_TYPE PRIMARY KEY (ID);
ALTER TABLE UI$PANEL_ALIGN ADD CONSTRAINT PK_UI$PANEL_ALIGN PRIMARY KEY (ID);
ALTER TABLE UI$PARAM_ALIGN ADD CONSTRAINT PK_UI$PARAM_ALIGN PRIMARY KEY (ID);
ALTER TABLE UI$PARAM_DIRECTION ADD CONSTRAINT PK_UI$PARAM_DIRECTION PRIMARY KEY (ID);
ALTER TABLE UI$PROCEDURE ADD CONSTRAINT PK_UI$BLOCK_DATASET PRIMARY KEY (ID);
ALTER TABLE UI$REFRESH_MODE ADD CONSTRAINT PK_UI$REFRESH_MODE PRIMARY KEY (ID);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE UI$ACTION_BIND ADD CONSTRAINT FK_UI$ACTION_BIND_1 FOREIGN KEY ("ACTION", "BLOCK") REFERENCES UI$BLOCK_ACTION (ID, "BLOCK") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$BLOCK ADD CONSTRAINT FK_UI$BLOCK_1 FOREIGN KEY (BLOCK_TYPE) REFERENCES UI$BLOCK_TYPE (ID);
ALTER TABLE UI$BLOCK_ACTION ADD CONSTRAINT FK_UI$BLOCK_ACTION_1 FOREIGN KEY ("BLOCK") REFERENCES UI$BLOCK (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$BLOCK_ACTION ADD CONSTRAINT FK_UI$BLOCK_ACTION_2 FOREIGN KEY (LINKS_TO) REFERENCES UI$BLOCK (ID) ON UPDATE CASCADE;
ALTER TABLE UI$BLOCK_ACTION ADD CONSTRAINT FK_UI$BLOCK_ACTION_3 FOREIGN KEY (ACTION_STYLE) REFERENCES UI$ACTION_STYLE (ID);
ALTER TABLE UI$BLOCK_ACTION ADD CONSTRAINT FK_UI$BLOCK_ACTION_4 FOREIGN KEY (REFRESH_MODE) REFERENCES UI$REFRESH_MODE (ID);
ALTER TABLE UI$BLOCK_PARAM ADD CONSTRAINT FK_UI$BLOCK_PARAM_1 FOREIGN KEY ("BLOCK", ENABLER_PARAM) REFERENCES UI$BLOCK_PARAM ("BLOCK", PARAM) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE UI$BLOCK_PARAM ADD CONSTRAINT FK_UI$BLOCK_PARAM_2 FOREIGN KEY ("BLOCK") REFERENCES UI$BLOCK (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$BLOCK_PARAM ADD CONSTRAINT FK_UI$BLOCK_PARAM_3 FOREIGN KEY (SOURCE_CHILD, SOURCE_FORM, SOURCE_BLOCK) REFERENCES UI$FORM_CHILD (ID, FORM, "BLOCK");
ALTER TABLE UI$BLOCK_PARAM ADD CONSTRAINT FK_UI$BLOCK_PARAM_4 FOREIGN KEY (SOURCE_BLOCK, SOURCE_PARAM) REFERENCES UI$BLOCK_PARAM ("BLOCK", PARAM);
ALTER TABLE UI$BLOCK_PARAM ADD CONSTRAINT FK_UI$PROCEDURE_PARAM_2 FOREIGN KEY (PARAM_DIRECTION) REFERENCES UI$PARAM_DIRECTION (ID);
ALTER TABLE UI$BLOCK_PARAM ADD CONSTRAINT FK_UI$PROCEDURE_PARAM_3 FOREIGN KEY (DATA_TYPE) REFERENCES UI$DATA_TYPE (ID);
ALTER TABLE UI$BLOCK_REF ADD CONSTRAINT FK_UI$BLOCK_REF_1 FOREIGN KEY ("BLOCK") REFERENCES UI$BLOCK (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$BLOCK_REF ADD CONSTRAINT FK_UI$BLOCK_REF_2 FOREIGN KEY (REFS_TO) REFERENCES UI$BLOCK (ID) ON UPDATE CASCADE;
ALTER TABLE UI$BLOCK_REF_BIND ADD CONSTRAINT FK_UI$BLOCK_REF_BIND_1 FOREIGN KEY (REF, "BLOCK") REFERENCES UI$BLOCK_REF (ID, "BLOCK") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$BLOCK_REF_BIND ADD CONSTRAINT FK_UI$BLOCK_REF_BIND_2 FOREIGN KEY ("BLOCK", SOURCE_PARAM) REFERENCES UI$BLOCK_PARAM ("BLOCK", PARAM) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$BLOCK_REF_PARAM ADD CONSTRAINT FK_UI$BLOCK_REF_PARAM_1 FOREIGN KEY (REF, "BLOCK") REFERENCES UI$BLOCK_REF (ID, "BLOCK") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$BLOCK_REF_PARAM ADD CONSTRAINT FK_UI$BLOCK_REF_PARAM_2 FOREIGN KEY ("BLOCK", PARAM) REFERENCES UI$BLOCK_PARAM ("BLOCK", PARAM) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$DEFAULT_ACTION ADD CONSTRAINT FK_UI$DEFAULT_ACTION_1 FOREIGN KEY (REFRESH_MODE) REFERENCES UI$REFRESH_MODE (ID);
ALTER TABLE UI$FORM ADD CONSTRAINT FK_UI$BLOCK_CONTAINER_1 FOREIGN KEY (ID) REFERENCES UI$BLOCK (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$FORM ADD CONSTRAINT FK_UI$FORM_1 FOREIGN KEY (MAIN_PROCEDURE) REFERENCES UI$PROCEDURE (ID) ON UPDATE CASCADE;
ALTER TABLE UI$FORM_CHILD ADD CONSTRAINT FK_UI$FORM_CHILD_1 FOREIGN KEY (PANEL, FORM) REFERENCES UI$FORM_PANEL (ID, FORM) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$FORM_CHILD ADD CONSTRAINT FK_UI$FORM_CHILD_2 FOREIGN KEY ("BLOCK") REFERENCES UI$BLOCK (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$FORM_CHILD ADD CONSTRAINT FK_UI$FORM_CHILD_3 FOREIGN KEY (PARAM_GROUP_ALIGN) REFERENCES UI$PARAM_ALIGN (ID);
ALTER TABLE UI$FORM_CHILD ADD CONSTRAINT FK_UI$FORM_CHILD_4 FOREIGN KEY (PARAM_ALIGN) REFERENCES UI$PARAM_ALIGN (ID);
ALTER TABLE UI$FORM_CHILD_PARAM ADD CONSTRAINT FK_UI$FORM_CHILD_PARAM_1 FOREIGN KEY ("BLOCK", PARAM) REFERENCES UI$BLOCK_PARAM ("BLOCK", PARAM) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$FORM_CHILD_PARAM ADD CONSTRAINT FK_UI$FORM_CHILD_PARAM_2 FOREIGN KEY (SOURCE_BLOCK, SOURCE_PARAM) REFERENCES UI$BLOCK_PARAM ("BLOCK", PARAM) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE UI$FORM_CHILD_PARAM ADD CONSTRAINT FK_UI$FORM_CHILD_PARAM_3 FOREIGN KEY (SOURCE_CHILD, FORM, SOURCE_BLOCK) REFERENCES UI$FORM_CHILD (ID, FORM, "BLOCK") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$FORM_CHILD_PARAM ADD CONSTRAINT FK_UI$FORM_CHILD_PARAM_4 FOREIGN KEY (FORM_CHILD, FORM, "BLOCK") REFERENCES UI$FORM_CHILD (ID, FORM, "BLOCK") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$FORM_CHILD_REF_BIND ADD CONSTRAINT FK_UI$FORM_CHILD_REF_BIND_1 FOREIGN KEY (FORM_CHILD, FORM, "BLOCK") REFERENCES UI$FORM_CHILD (ID, FORM, "BLOCK");
ALTER TABLE UI$FORM_CHILD_REF_BIND ADD CONSTRAINT FK_UI$FORM_CHILD_REF_BIND_3 FOREIGN KEY (SOURCE_BLOCK, SOURCE_PARAM) REFERENCES UI$BLOCK_PARAM ("BLOCK", PARAM);
ALTER TABLE UI$FORM_CHILD_REF_BIND ADD CONSTRAINT FK_UI$FORM_CHILD_REF_BIND_4 FOREIGN KEY (SOURCE_CHILD, FORM, SOURCE_BLOCK) REFERENCES UI$FORM_CHILD (ID, FORM, "BLOCK");
ALTER TABLE UI$FORM_CHILD_REF_BIND ADD CONSTRAINT FK_UI$FORM_CHILD_REF_BIND_5 FOREIGN KEY (REF, "BLOCK") REFERENCES UI$BLOCK_REF (ID, "BLOCK");
ALTER TABLE UI$FORM_PANEL ADD CONSTRAINT FK_UI$FORM_PANEL_1 FOREIGN KEY (FORM) REFERENCES UI$FORM (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE UI$FORM_PANEL ADD CONSTRAINT FK_UI$FORM_PANEL_2 FOREIGN KEY (PARENT, FORM) REFERENCES UI$FORM_PANEL (ID, FORM);
ALTER TABLE UI$FORM_PANEL ADD CONSTRAINT FK_UI$FORM_PANEL_4 FOREIGN KEY (ALIGN) REFERENCES UI$PANEL_ALIGN (ID);
ALTER TABLE UI$MENU_ITEM ADD CONSTRAINT FK_UI$MENU_ITEM_1 FOREIGN KEY (ITEM_TYPE) REFERENCES UI$MENU_ITEM_TYPE (ID);
ALTER TABLE UI$MENU_ITEM ADD CONSTRAINT FK_UI$MENU_ITEM_2 FOREIGN KEY (PARENT) REFERENCES UI$MENU_ITEM (ID);
ALTER TABLE UI$MENU_ITEM ADD CONSTRAINT FK_UI$MENU_ITEM_3 FOREIGN KEY ("BLOCK") REFERENCES UI$BLOCK (ID) ON UPDATE CASCADE;
ALTER TABLE UI$PROCEDURE ADD CONSTRAINT FK_UI$BLOCK_DATASET_2 FOREIGN KEY (ID) REFERENCES UI$BLOCK (ID) ON DELETE CASCADE ON UPDATE CASCADE;


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: IBE$VERSION_HISTORY_BI */
CREATE OR ALTER TRIGGER IBE$VERSION_HISTORY_BI FOR IBE$VERSION_HISTORY
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.IBE$VH_ID IS NULL) THEN
    NEW.IBE$VH_ID = GEN_ID(IBE$VERSION_HISTORY_ID_GEN,1);
  NEW.IBE$VH_USER_NAME = USER;
  NEW.IBE$VH_MODIFY_DATE = 'NOW';
END
^

/* Trigger: UI$BLOCK_REF_BI */
CREATE OR ALTER TRIGGER UI$BLOCK_REF_BI FOR UI$BLOCK_REF
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_ui$block_ref_id,1);
end
^

/* Trigger: UI$FORM_CHILD_BI */
CREATE OR ALTER TRIGGER UI$FORM_CHILD_BI FOR UI$FORM_CHILD
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_ui$form_child_id,1);
end
^

/* Trigger: UI$FORM_PANEL_BI */
CREATE OR ALTER TRIGGER UI$FORM_PANEL_BI FOR UI$FORM_PANEL
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_ui$form_panel_id,1);
end
^

/* Trigger: UI$MENU_ITEM_BI */
CREATE OR ALTER TRIGGER UI$MENU_ITEM_BI FOR UI$MENU_ITEM
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_ui$menu_item_id,1);
end
^

SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

CREATE OR ALTER PROCEDURE CR_UI$MENU
RETURNS (
    ID INTEGER,
    NAME D_NAME,
    ITEM_TYPE D_IDENT,
    PARENT INTEGER,
    "BLOCK" D_IDENT,
    ORDER_NUM SMALLINT)
AS
begin
  for
    select mi.id, mi.name, mi.item_type, mi.parent, mi.block, mi.order_num
    from ui$menu_item mi
    order by mi.order_num
    into :id, :name, :item_type, :parent, :"BLOCK", :order_num
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE CR_UI$MENU_ITEM_TYPE (
    I_ID VARCHAR(30) = null)
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100))
AS
 BEGIN
FOR SELECT
ID,NAME

FROM UI$MENU_ITEM_TYPE T 

WHERE
(T.ID = :I_ID OR :I_ID IS NULL) AND
1=1

INTO :ID,:NAME 
DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$ACTION_BIND_CR (
    I_ACTION VARCHAR(30),
    I_PARAM VARCHAR(30),
    I_BLOCK VARCHAR(30))
RETURNS (
    "BLOCK" VARCHAR(30),
    "ACTION" VARCHAR(30),
    PARAM VARCHAR(30),
    DESTINATION_PARAM VARCHAR(30))
AS
BEGIN
  FOR
    SELECT A.BLOCK,A.ID,T.PARAM,P.PARAM
    FROM UI$BLOCK_ACTION A
    JOIN UI$BLOCK_PARAM P ON P."BLOCK" = A.LINKS_TO
    LEFT JOIN UI$ACTION_BIND T ON T.DESTINATION_PARAM = P.PARAM AND T."BLOCK" = A.BLOCK AND T."ACTION" = A.ID
    WHERE
      (A.ID = :I_ACTION OR :I_ACTION IS NULL) AND
      (P.PARAM = :I_PARAM OR :I_PARAM IS NULL) AND
      (A.BLOCK = :I_BLOCK OR :I_BLOCK IS NULL) AND
      1=1
    INTO :BLOCK,:ACTION,:PARAM,:DESTINATION_PARAM
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$ACTION_BIND_CR_D (
    I_BLOCK VARCHAR(30),
    I_ACTION VARCHAR(30),
    I_PARAM VARCHAR(30),
    I_DESTINATION_PARAM VARCHAR(30))
RETURNS (
    "BLOCK" VARCHAR(30),
    "ACTION" VARCHAR(30),
    PARAM VARCHAR(30),
    DESTINATION_PARAM VARCHAR(30))
AS
BEGIN
  FOR
    SELECT A.BLOCK,A.ID,T.PARAM,:I_DESTINATION_PARAM
    FROM UI$BLOCK_ACTION A
    LEFT JOIN UI$ACTION_BIND T ON T."BLOCK" = A."BLOCK" AND T.DESTINATION_PARAM = :I_DESTINATION_PARAM AND T.ACTION = :I_ACTION
    WHERE
      A.BLOCK = :I_BLOCK AND
      A.ID = :I_ACTION AND
      1=1
    INTO :BLOCK,:ACTION,:PARAM,:DESTINATION_PARAM
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$ACTION_BIND_DEL (
    I_BLOCK VARCHAR(30),
    I_ACTION VARCHAR(30),
    I_PARAM VARCHAR(30),
    I_DESTINATION_PARAM VARCHAR(30))
AS
 BEGIN
  DELETE FROM UI$ACTION_BIND T
  WHERE T.BLOCK=:I_BLOCK AND T.ACTION=:I_ACTION AND T.PARAM=:I_PARAM AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$ACTION_BIND_UPD (
    I_BLOCK VARCHAR(30),
    I_ACTION VARCHAR(30),
    I_PARAM VARCHAR(30),
    I_DESTINATION_PARAM VARCHAR(30))
AS
BEGIN
  MERGE INTO UI$ACTION_BIND T
    USING (SELECT NULL V FROM RDB$DATABASE)
    ON (T.BLOCK=:I_BLOCK AND T.ACTION=:I_ACTION AND T.DESTINATION_PARAM=:I_DESTINATION_PARAM)
    WHEN MATCHED THEN UPDATE SET T.PARAM=:I_PARAM
    WHEN NOT MATCHED THEN INSERT (BLOCK, ACTION, PARAM, DESTINATION_PARAM)
      VALUES (:I_BLOCK, :I_ACTION, :I_PARAM, :I_DESTINATION_PARAM);
END^


CREATE OR ALTER PROCEDURE UI$ACTION_STYLE_CR (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100))
AS
 BEGIN
  FOR
    SELECT T.ID,T.NAME
    FROM UI$ACTION_STYLE T     
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      1=1
    INTO :ID,:NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$ACTION_STYLE_CR_D (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100))
AS
 BEGIN
  FOR
    SELECT T.ID,T.NAME
    FROM UI$ACTION_STYLE T 
    WHERE
      T.ID = :I_ID AND
      1=1
    INTO :ID,:NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$ACTION_STYLE_DEL (
    I_ID VARCHAR(30),
    I_NAME VARCHAR(100))
AS
 BEGIN
  DELETE FROM UI$ACTION_STYLE T
  WHERE T.ID=:I_ID AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$ACTION_STYLE_INS (
    I_ID VARCHAR(30),
    I_NAME VARCHAR(100))
AS
 BEGIN
  INSERT INTO UI$ACTION_STYLE (ID,NAME)
  VALUES  (:I_ID,:I_NAME);
END^


CREATE OR ALTER PROCEDURE UI$ACTION_STYLE_UPD (
    I_ID VARCHAR(30),
    I_NAME VARCHAR(100))
AS
 BEGIN
  UPDATE UI$ACTION_STYLE T
  SET T.NAME=:I_NAME
  WHERE T.ID=:I_ID AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$ADD_TO_MENU (
    I_MENU_ITEM_PARENT INTEGER,
    I_MENU_ITEM_ORDER_NUM SMALLINT,
    I_BLOCK D_IDENT)
AS
begin
  insert into ui$menu_item (name, item_type, parent, "BLOCK", order_num)
    select b.name, 'block', :i_menu_item_parent, :i_block, :i_menu_item_order_num
    from ui$block b
    where b.id = :i_block;
end^


CREATE OR ALTER PROCEDURE UI$BLOCK_ACTION_CR (
    I_ID VARCHAR(30),
    I_BLOCK VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    "BLOCK" VARCHAR(30),
    CAPTION VARCHAR(100),
    LINKS_TO VARCHAR(30),
    ACTION_STYLE VARCHAR(30),
    IMAGE_INDEX INTEGER,
    ORDER_NUM SMALLINT,
    REFRESH_MODE VARCHAR(30),
    L_BLOCK_NAME VARCHAR(100),
    L_LINKS_TO_NAME VARCHAR(100),
    L_ACTION_STYLE_NAME VARCHAR(100),
    L_REFRESH_MODE_NAME VARCHAR(100))
AS
 BEGIN
  FOR
    SELECT T.ID,T.BLOCK,T.CAPTION,T.LINKS_TO,T.ACTION_STYLE,T.IMAGE_INDEX,T.ORDER_NUM,T.REFRESH_MODE,L1.NAME AS L_BLOCK_NAME,L2.NAME AS L_LINKS_TO_NAME,L3.NAME AS L_ACTION_STYLE_NAME,L4.NAME AS L_REFRESH_MODE_NAME
    FROM UI$BLOCK_ACTION T     
    LEFT JOIN UI$BLOCK L1 ON L1.ID=T.BLOCK
    LEFT JOIN UI$BLOCK L2 ON L2.ID=T.LINKS_TO
    LEFT JOIN UI$ACTION_STYLE L3 ON L3.ID=T.ACTION_STYLE
    LEFT JOIN UI$REFRESH_MODE L4 ON L4.ID=T.REFRESH_MODE
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      (T.BLOCK = :I_BLOCK OR :I_BLOCK IS NULL) AND
      1=1
    INTO :ID,:BLOCK,:CAPTION,:LINKS_TO,:ACTION_STYLE,:IMAGE_INDEX,:ORDER_NUM,:REFRESH_MODE,:L_BLOCK_NAME,:L_LINKS_TO_NAME,:L_ACTION_STYLE_NAME,:L_REFRESH_MODE_NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_ACTION_CR_D (
    I_ID VARCHAR(30),
    I_BLOCK VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    "BLOCK" VARCHAR(30),
    CAPTION VARCHAR(100),
    LINKS_TO VARCHAR(30),
    ACTION_STYLE VARCHAR(30),
    IMAGE_INDEX INTEGER,
    ORDER_NUM SMALLINT,
    REFRESH_MODE VARCHAR(30))
AS
 BEGIN
  FOR
    SELECT T.ID,T.BLOCK,T.CAPTION,T.LINKS_TO,T.ACTION_STYLE,T.IMAGE_INDEX,T.ORDER_NUM,T.REFRESH_MODE
    FROM UI$BLOCK_ACTION T 
    WHERE
      T.ID = :I_ID AND
      T.BLOCK = :I_BLOCK AND
      1=1
    INTO :ID,:BLOCK,:CAPTION,:LINKS_TO,:ACTION_STYLE,:IMAGE_INDEX,:ORDER_NUM,:REFRESH_MODE
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_ACTION_DEL (
    I_ID VARCHAR(30),
    I_BLOCK VARCHAR(30),
    I_CAPTION VARCHAR(100),
    I_LINKS_TO VARCHAR(30),
    I_ACTION_STYLE VARCHAR(30),
    I_IMAGE_INDEX INTEGER,
    I_ORDER_NUM SMALLINT,
    I_REFRESH_MODE VARCHAR(30))
AS
 BEGIN
  DELETE FROM UI$BLOCK_ACTION T
  WHERE T.ID=:I_ID AND T.BLOCK=:I_BLOCK AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_ACTION_INS (
    I_ID VARCHAR(30),
    I_BLOCK VARCHAR(30),
    I_CAPTION VARCHAR(100),
    I_LINKS_TO VARCHAR(30),
    I_ACTION_STYLE VARCHAR(30),
    I_IMAGE_INDEX INTEGER,
    I_ORDER_NUM SMALLINT,
    I_REFRESH_MODE VARCHAR(30))
AS
 BEGIN
  INSERT INTO UI$BLOCK_ACTION (ID,BLOCK,CAPTION,LINKS_TO,ACTION_STYLE,IMAGE_INDEX,ORDER_NUM,REFRESH_MODE)
  VALUES  (:I_ID,:I_BLOCK,:I_CAPTION,:I_LINKS_TO,:I_ACTION_STYLE,:I_IMAGE_INDEX,:I_ORDER_NUM,:I_REFRESH_MODE);
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_ACTION_UPD (
    I_ID VARCHAR(30),
    I_BLOCK VARCHAR(30),
    I_CAPTION VARCHAR(100),
    I_LINKS_TO VARCHAR(30),
    I_ACTION_STYLE VARCHAR(30),
    I_IMAGE_INDEX INTEGER,
    I_ORDER_NUM SMALLINT,
    I_REFRESH_MODE VARCHAR(30))
AS
 BEGIN
  UPDATE UI$BLOCK_ACTION T
  SET T.CAPTION=:I_CAPTION,T.LINKS_TO=:I_LINKS_TO,T.ACTION_STYLE=:I_ACTION_STYLE,T.IMAGE_INDEX=:I_IMAGE_INDEX,T.ORDER_NUM=:I_ORDER_NUM,T.REFRESH_MODE=:I_REFRESH_MODE
  WHERE T.ID=:I_ID AND T.BLOCK=:I_BLOCK AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_CR (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    BLOCK_TYPE VARCHAR(30),
    NAME VARCHAR(100),
    CUSTOM_CLASS VARCHAR(100),
    IS_MODAL SMALLINT,
    L_BLOCK_TYPE_NAME VARCHAR(100))
AS
 BEGIN
  FOR
    SELECT T.ID,T.BLOCK_TYPE,T.NAME,T.CUSTOM_CLASS,T.IS_MODAL,L_1.NAME AS L_BLOCK_TYPE_NAME
    FROM UI$BLOCK T
    LEFT JOIN UI$BLOCK_TYPE L_1 ON L_1.ID = T.BLOCK_TYPE
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      1=1
    INTO :ID,:BLOCK_TYPE,:NAME,:CUSTOM_CLASS,:IS_MODAL,:L_BLOCK_TYPE_NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_CR_D (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    BLOCK_TYPE VARCHAR(30),
    NAME VARCHAR(100),
    CUSTOM_CLASS VARCHAR(100),
    IS_MODAL SMALLINT)
AS
 BEGIN
  FOR
    SELECT T.ID,T.BLOCK_TYPE,T.NAME,T.CUSTOM_CLASS,T.IS_MODAL
    FROM UI$BLOCK T 
    WHERE
      T.ID = :I_ID AND
      1=1
    INTO :ID,:BLOCK_TYPE,:NAME,:CUSTOM_CLASS,:IS_MODAL
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_DEL (
    I_ID VARCHAR(30),
    I_BLOCK_TYPE VARCHAR(30),
    I_NAME VARCHAR(100),
    I_CUSTOM_CLASS VARCHAR(100),
    I_IS_MODAL SMALLINT)
AS
 BEGIN
  DELETE FROM UI$BLOCK T
  WHERE T.ID=:I_ID AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_INS (
    I_ID VARCHAR(30),
    I_BLOCK_TYPE VARCHAR(30),
    I_NAME VARCHAR(100),
    I_CUSTOM_CLASS VARCHAR(100),
    I_IS_MODAL SMALLINT)
AS
 BEGIN
  INSERT INTO UI$BLOCK (ID,BLOCK_TYPE,NAME,CUSTOM_CLASS,IS_MODAL)
  VALUES  (:I_ID,:I_BLOCK_TYPE,:I_NAME,:I_CUSTOM_CLASS,:I_IS_MODAL);
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_PARAM_CR (
    I_BLOCK VARCHAR(30),
    I_PARAM VARCHAR(30))
RETURNS (
    "BLOCK" VARCHAR(30),
    PARAM VARCHAR(30),
    PARAM_DIRECTION VARCHAR(30),
    DATA_TYPE VARCHAR(30),
    ORDER_NUM SMALLINT,
    GROUP_NAME VARCHAR(100),
    CAPTION VARCHAR(100),
    ENABLER_PARAM VARCHAR(30),
    SOURCE_CHILD INTEGER,
    SOURCE_PARAM VARCHAR(30),
    INDEX_IN_KEY SMALLINT,
    INDEX_IN_PARENT SMALLINT,
    INDEX_IN_NAME SMALLINT,
    VISIBLE SMALLINT,
    REQUIRED SMALLINT,
    READ_ONLY SMALLINT,
    L_BLOCK_NAME VARCHAR(100),
    L_PARAM_DIRECTION_NAME VARCHAR(100),
    L_DATA_TYPE_NAME VARCHAR(100))
AS
BEGIN
  FOR
    SELECT T.BLOCK,T.PARAM,T.PARAM_DIRECTION,T.DATA_TYPE,T.ORDER_NUM,T.GROUP_NAME,T.CAPTION,T.ENABLER_PARAM,T.SOURCE_CHILD,T.SOURCE_PARAM,T.INDEX_IN_KEY,T.INDEX_IN_PARENT,T.INDEX_IN_NAME,T.VISIBLE,T.REQUIRED,T.READ_ONLY,L_2.NAME AS L_BLOCK_NAME,L_4.NAME AS L_PARAM_DIRECTION_NAME,L_5.NAME AS L_DATA_TYPE_NAME
    FROM UI$BLOCK_PARAM T
    LEFT JOIN UI$BLOCK_PARAM L_1 ON L_1."BLOCK" = T.BLOCK and L_1.PARAM = T.ENABLER_PARAM
    LEFT JOIN UI$BLOCK L_2 ON L_2.ID = T.BLOCK
    LEFT JOIN UI$FORM_CHILD L_3 ON L_3.ID = T.SOURCE_CHILD
    LEFT JOIN UI$PARAM_DIRECTION L_4 ON L_4.ID = T.PARAM_DIRECTION
    LEFT JOIN UI$DATA_TYPE L_5 ON L_5.ID = T.DATA_TYPE
    WHERE
      (T.BLOCK = :I_BLOCK OR :I_BLOCK IS NULL) AND
      (T.PARAM = :I_PARAM OR :I_PARAM IS NULL) AND
      1=1
    ORDER BY T.BLOCK, T.ORDER_NUM
    INTO :BLOCK,:PARAM,:PARAM_DIRECTION,:DATA_TYPE,:ORDER_NUM,:GROUP_NAME,:CAPTION,:ENABLER_PARAM,:SOURCE_CHILD,:SOURCE_PARAM,:INDEX_IN_KEY,:INDEX_IN_PARENT,:INDEX_IN_NAME,:VISIBLE,:REQUIRED,:READ_ONLY,:L_BLOCK_NAME,:L_PARAM_DIRECTION_NAME,:L_DATA_TYPE_NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_PARAM_CR_D (
    I_BLOCK VARCHAR(30),
    I_PARAM VARCHAR(30))
RETURNS (
    "BLOCK" VARCHAR(30),
    PARAM VARCHAR(30),
    PARAM_DIRECTION VARCHAR(30),
    DATA_TYPE VARCHAR(30),
    ORDER_NUM SMALLINT,
    CALL_ORDER_NUM SMALLINT,
    GROUP_NAME VARCHAR(100),
    CAPTION VARCHAR(100),
    ENABLER_PARAM VARCHAR(30),
    SOURCE_CHILD INTEGER,
    SOURCE_PARAM VARCHAR(30),
    INDEX_IN_KEY SMALLINT,
    INDEX_IN_PARENT SMALLINT,
    INDEX_IN_NAME SMALLINT,
    VISIBLE SMALLINT,
    REQUIRED SMALLINT,
    READ_ONLY SMALLINT)
AS
BEGIN
  FOR
    SELECT
      T.BLOCK,T.PARAM,T.PARAM_DIRECTION,T.DATA_TYPE,T.ORDER_NUM,CALL_ORDER_NUM,
      T.GROUP_NAME,T.CAPTION,T.ENABLER_PARAM,T.SOURCE_CHILD,T.SOURCE_PARAM,
      T.INDEX_IN_KEY,T.INDEX_IN_PARENT,T.INDEX_IN_NAME,
      T.VISIBLE,T.REQUIRED,T.READ_ONLY
    FROM UI$BLOCK_PARAM T 
    WHERE
      T.BLOCK = :I_BLOCK AND
      T.PARAM = :I_PARAM AND
      1=1
    INTO
     :BLOCK,:PARAM,:PARAM_DIRECTION,:DATA_TYPE,:ORDER_NUM,:CALL_ORDER_NUM,
     :GROUP_NAME,:CAPTION,:ENABLER_PARAM,:SOURCE_CHILD,:SOURCE_PARAM,
     :INDEX_IN_KEY,:INDEX_IN_PARENT,:INDEX_IN_NAME,
     :VISIBLE,:REQUIRED,:READ_ONLY
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_PARAM_DEL (
    I_BLOCK VARCHAR(30),
    I_PARAM VARCHAR(30),
    I_PARAM_DIRECTION VARCHAR(30),
    I_DATA_TYPE VARCHAR(30),
    I_ORDER_NUM SMALLINT,
    I_GROUP_NAME VARCHAR(100),
    I_CAPTION VARCHAR(100),
    I_ENABLER_PARAM VARCHAR(30),
    I_SOURCE_BLOCK INTEGER,
    I_SOURCE_PARAM VARCHAR(30),
    I_INDEX_IN_KEY SMALLINT,
    I_INDEX_IN_PARENT SMALLINT,
    I_INDEX_IN_NAME SMALLINT,
    I_VISIBLE SMALLINT,
    I_REQUIRED SMALLINT,
    I_READ_ONLY SMALLINT)
AS
 BEGIN
  DELETE FROM UI$BLOCK_PARAM T
  WHERE T.BLOCK=:I_BLOCK AND T.PARAM=:I_PARAM AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_PARAM_INS (
    I_BLOCK VARCHAR(30),
    I_PARAM VARCHAR(30),
    I_PARAM_DIRECTION VARCHAR(30),
    I_DATA_TYPE VARCHAR(30),
    I_ORDER_NUM SMALLINT,
    I_CALL_ORDER_NUM SMALLINT,
    I_GROUP_NAME VARCHAR(100),
    I_CAPTION VARCHAR(100),
    I_ENABLER_PARAM VARCHAR(30),
    I_SOURCE_CHILD INTEGER,
    I_SOURCE_PARAM VARCHAR(30),
    I_INDEX_IN_KEY SMALLINT,
    I_INDEX_IN_PARENT SMALLINT,
    I_INDEX_IN_NAME SMALLINT,
    I_VISIBLE SMALLINT,
    I_REQUIRED SMALLINT,
    I_READ_ONLY SMALLINT)
AS
  DECLARE VARIABLE L_SOURCE_FORM D_IDENT;
  DECLARE VARIABLE L_SOURCE_BLOCK D_IDENT;
BEGIN
  SELECT MIN(C.FORM), MIN(C."BLOCK")
    FROM UI$FORM_CHILD C
    WHERE C.ID = :I_SOURCE_CHILD
    INTO :L_SOURCE_FORM, :L_SOURCE_BLOCK;

  INSERT INTO UI$BLOCK_PARAM (
      BLOCK,PARAM,PARAM_DIRECTION,DATA_TYPE,ORDER_NUM,
      CALL_ORDER_NUM, GROUP_NAME, CAPTION,ENABLER_PARAM,
      SOURCE_FORM, SOURCE_BLOCK, SOURCE_CHILD,SOURCE_PARAM,
      INDEX_IN_KEY,INDEX_IN_PARENT,INDEX_IN_NAME,
      VISIBLE,REQUIRED,READ_ONLY
    )
    VALUES (
      :I_BLOCK,:I_PARAM,:I_PARAM_DIRECTION,:I_DATA_TYPE,:I_ORDER_NUM,
      :I_CALL_ORDER_NUM,:I_GROUP_NAME,:I_CAPTION,:I_ENABLER_PARAM,
      :L_SOURCE_FORM, :L_SOURCE_BLOCK, :I_SOURCE_CHILD,:I_SOURCE_PARAM,
      :I_INDEX_IN_KEY,:I_INDEX_IN_PARENT,:I_INDEX_IN_NAME,
      :I_VISIBLE,:I_REQUIRED,:I_READ_ONLY
    );
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_PARAM_UPD (
    I_BLOCK VARCHAR(30),
    I_PARAM VARCHAR(30),
    I_PARAM_DIRECTION VARCHAR(30),
    I_DATA_TYPE VARCHAR(30),
    I_ORDER_NUM SMALLINT,
    I_CALL_ORDER_NUM SMALLINT,
    I_GROUP_NAME VARCHAR(100),
    I_CAPTION VARCHAR(100),
    I_ENABLER_PARAM VARCHAR(30),
    I_SOURCE_CHILD INTEGER,
    I_SOURCE_PARAM VARCHAR(30),
    I_INDEX_IN_KEY SMALLINT,
    I_INDEX_IN_PARENT SMALLINT,
    I_INDEX_IN_NAME SMALLINT,
    I_VISIBLE SMALLINT,
    I_REQUIRED SMALLINT,
    I_READ_ONLY SMALLINT)
AS
BEGIN
  UPDATE UI$BLOCK_PARAM T
  SET
    T.PARAM_DIRECTION=:I_PARAM_DIRECTION,
    T.DATA_TYPE=:I_DATA_TYPE,
    T.ORDER_NUM=:I_ORDER_NUM,
    T.CALL_ORDER_NUM=:I_CALL_ORDER_NUM,
    T.GROUP_NAME=:I_GROUP_NAME,
    T.CAPTION=:I_CAPTION,
    T.ENABLER_PARAM=:I_ENABLER_PARAM,
    T.SOURCE_CHILD=case when :I_SOURCE_CHILD = 0 then null else :I_SOURCE_CHILD end,
    T.SOURCE_PARAM=:I_SOURCE_PARAM,
    T.INDEX_IN_KEY=:I_INDEX_IN_KEY,
    T.INDEX_IN_PARENT=:I_INDEX_IN_PARENT,
    T.INDEX_IN_NAME=:I_INDEX_IN_NAME,
    T.VISIBLE=:I_VISIBLE,
    T.REQUIRED=:I_REQUIRED,
    T.READ_ONLY=:I_READ_ONLY
  WHERE T.BLOCK=:I_BLOCK AND T.PARAM=:I_PARAM AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_BIND_CR (
    I_REF INTEGER,
    I_BLOCK VARCHAR(30),
    I_DESTINATION_PARAM VARCHAR(30))
RETURNS (
    REF INTEGER,
    "BLOCK" VARCHAR(30),
    DESTINATION_PARAM VARCHAR(30),
    SOURCE_PARAM VARCHAR(30))
AS
BEGIN
  FOR
/*
    SELECT T.REF,T.BLOCK,T.DESTINATION_PARAM,T.SOURCE_PARAM
    FROM UI$BLOCK_REF_BIND T     
    LEFT JOIN UI$BLOCK_REF L1 ON L1.ID=T.REF AND L1.BLOCK=T.BLOCK
    LEFT JOIN UI$BLOCK_PARAM L2 ON L2.BLOCK=T.BLOCK AND L2.PARAM=T.SOURCE_PARAM
    WHERE
      (T.REF = :I_REF OR :I_REF IS NULL) AND
      (T.BLOCK = :I_BLOCK OR :I_BLOCK IS NULL) AND
      (T.DESTINATION_PARAM = :I_DESTINATION_PARAM OR :I_DESTINATION_PARAM IS NULL) AND
      1=1
*/
    select r.id, r.block, rp.param, b.source_param
    from ui$block_ref r
    join ui$block_param rp on rp."BLOCK" = r.refs_to and rp.param_direction in ('in', 'in_out')
    left join ui$block_ref_bind b on b.ref = :i_ref and b.destination_param = rp.param
    where
      r.id = :i_ref and
      1=1

    INTO :REF,:BLOCK,:DESTINATION_PARAM,:SOURCE_PARAM
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_BIND_CR_D (
    I_REF INTEGER,
    I_BLOCK VARCHAR(30),
    I_DESTINATION_PARAM VARCHAR(30))
RETURNS (
    REF INTEGER,
    "BLOCK" VARCHAR(30),
    DESTINATION_PARAM VARCHAR(30),
    SOURCE_PARAM VARCHAR(30))
AS
 BEGIN
  FOR
    SELECT T.REF,T.BLOCK,T.DESTINATION_PARAM,T.SOURCE_PARAM
    FROM UI$BLOCK_REF_BIND T 
    WHERE
      T.REF = :I_REF AND
      T.BLOCK = :I_BLOCK AND
      T.DESTINATION_PARAM = :I_DESTINATION_PARAM AND
      1=1
    INTO :REF,:BLOCK,:DESTINATION_PARAM,:SOURCE_PARAM
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_BIND_DEL (
    I_REF INTEGER,
    I_BLOCK VARCHAR(30),
    I_DESTINATION_PARAM VARCHAR(30),
    I_SOURCE_PARAM VARCHAR(30))
AS
 BEGIN
  DELETE FROM UI$BLOCK_REF_BIND T
  WHERE T.REF=:I_REF AND T.BLOCK=:I_BLOCK AND T.DESTINATION_PARAM=:I_DESTINATION_PARAM AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_BIND_INS (
    I_REF INTEGER,
    I_BLOCK VARCHAR(30),
    I_DESTINATION_PARAM VARCHAR(30),
    I_SOURCE_PARAM VARCHAR(30))
AS
 BEGIN
  INSERT INTO UI$BLOCK_REF_BIND (REF,BLOCK,DESTINATION_PARAM,SOURCE_PARAM)
  VALUES  (:I_REF,:I_BLOCK,:I_DESTINATION_PARAM,:I_SOURCE_PARAM);
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_BIND_UPD (
    I_REF INTEGER,
    I_BLOCK VARCHAR(30),
    I_DESTINATION_PARAM VARCHAR(30),
    I_SOURCE_PARAM VARCHAR(30))
AS
BEGIN
  merge into UI$BLOCK_REF_BIND d
    using (select null v from rdb$database)
    on (d.ref = :i_ref and d."BLOCK" = :i_block and d.destination_param = :i_destination_param)
    when matched then update set
      d.source_param = :i_source_param
    when not matched then insert (ref,block,destination_param,source_param)
  values  (:i_ref,:i_block,:i_destination_param,:i_source_param);

/*
  UPDATE UI$BLOCK_REF_BIND T
  SET T.SOURCE_PARAM=:I_SOURCE_PARAM
  WHERE T.REF=:I_REF AND T.BLOCK=:I_BLOCK AND T.DESTINATION_PARAM=:I_DESTINATION_PARAM AND 1=1;
*/
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_CR (
    I_ID INTEGER,
    I_BLOCK VARCHAR(30))
RETURNS (
    ID INTEGER,
    "BLOCK" VARCHAR(30),
    REFS_TO VARCHAR(30),
    L_BLOCK_NAME VARCHAR(100),
    L_REFS_TO_NAME VARCHAR(100))
AS
 BEGIN
  FOR
    SELECT T.ID,T.BLOCK,T.REFS_TO,L1.NAME AS L_BLOCK_NAME,L2.NAME AS L_REFS_TO_NAME
    FROM UI$BLOCK_REF T     
    LEFT JOIN UI$BLOCK L1 ON L1.ID=T.BLOCK
    LEFT JOIN UI$BLOCK L2 ON L2.ID=T.REFS_TO
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      (T.BLOCK = :I_BLOCK OR :I_BLOCK IS NULL) AND
      1=1
    INTO :ID,:BLOCK,:REFS_TO,:L_BLOCK_NAME,:L_REFS_TO_NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_CR_D (
    I_ID INTEGER,
    I_BLOCK VARCHAR(30))
RETURNS (
    ID INTEGER,
    "BLOCK" VARCHAR(30),
    REFS_TO VARCHAR(30))
AS
 BEGIN
  FOR
    SELECT T.ID,T.BLOCK,T.REFS_TO
    FROM UI$BLOCK_REF T 
    WHERE
      T.ID = :I_ID AND
      T.BLOCK = :I_BLOCK AND
      1=1
    INTO :ID,:BLOCK,:REFS_TO
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_DEL (
    I_ID INTEGER,
    I_BLOCK VARCHAR(30),
    I_REFS_TO VARCHAR(30))
AS
 BEGIN
  DELETE FROM UI$BLOCK_REF T
  WHERE T.ID=:I_ID AND T.BLOCK=:I_BLOCK AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_INS (
    I_ID INTEGER,
    I_BLOCK VARCHAR(30),
    I_REFS_TO VARCHAR(30))
AS
 BEGIN
  INSERT INTO UI$BLOCK_REF (ID,BLOCK,REFS_TO)
  VALUES  (:I_ID,:I_BLOCK,:I_REFS_TO);
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_PARAM_CR (
    I_REF INTEGER,
    I_BLOCK VARCHAR(30),
    I_PARAM VARCHAR(30))
RETURNS (
    REF INTEGER,
    "BLOCK" VARCHAR(30),
    PARAM VARCHAR(30),
    ORDER_NUM SMALLINT,
    IS_MAIN_PARAM SMALLINT)
AS
BEGIN
  FOR
/*
    SELECT T.REF,T.BLOCK,T.PARAM,T.ORDER_NUM,T.IS_MAIN_PARAM
    FROM UI$BLOCK_REF_PARAM T     
    LEFT JOIN UI$BLOCK_REF L1 ON L1.ID=T.REF AND L1.BLOCK=T.BLOCK
    LEFT JOIN UI$BLOCK_PARAM L2 ON L2.BLOCK=T.BLOCK AND L2.PARAM=T.PARAM
    WHERE
      (T.REF = :I_REF OR :I_REF IS NULL) AND
      (T.BLOCK = :I_BLOCK OR :I_BLOCK IS NULL) AND
      (T.PARAM = :I_PARAM OR :I_PARAM IS NULL) AND
      1=1
*/
    select :i_ref, :i_block, p.param, rp.order_num, rp.is_main_param
    from UI$BLOCK_REF r
    join ui$block_param p on p."BLOCK" = :i_block
    left join ui$block_ref_param rp on rp."BLOCK" = :i_block and rp.ref = :i_ref and rp.param = p.param
    where
      r.id = :i_ref and
      r."BLOCK" = :i_block and
      1=1
    INTO :REF,:BLOCK,:PARAM,:ORDER_NUM,:IS_MAIN_PARAM
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_PARAM_CR_D (
    I_REF INTEGER,
    I_BLOCK VARCHAR(30),
    I_PARAM VARCHAR(30))
RETURNS (
    REF INTEGER,
    "BLOCK" VARCHAR(30),
    PARAM VARCHAR(30),
    ORDER_NUM SMALLINT,
    IS_MAIN_PARAM SMALLINT)
AS
BEGIN
  FOR
    SELECT :I_REF, :I_BLOCK, P.PARAM, RP.ORDER_NUM, RP.IS_MAIN_PARAM
    FROM UI$BLOCK_REF R
    JOIN UI$BLOCK_PARAM P ON P."BLOCK" = :I_BLOCK AND P.PARAM = :I_PARAM
    LEFT JOIN UI$BLOCK_REF_PARAM RP ON RP."BLOCK" = :I_BLOCK AND RP.REF = :I_REF AND RP.PARAM = P.PARAM
    WHERE
      R.ID = :I_REF AND
      R."BLOCK" = :I_BLOCK AND
      1=1
    INTO :REF,:BLOCK,:PARAM,:ORDER_NUM,:IS_MAIN_PARAM
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_PARAM_DEL (
    I_REF INTEGER,
    I_BLOCK VARCHAR(30),
    I_PARAM VARCHAR(30),
    I_ORDER_NUM SMALLINT,
    I_IS_MAIN_PARAM SMALLINT)
AS
 BEGIN
  DELETE FROM UI$BLOCK_REF_PARAM T
  WHERE T.REF=:I_REF AND T.BLOCK=:I_BLOCK AND T.PARAM=:I_PARAM AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_PARAM_UPD (
    I_REF INTEGER,
    I_BLOCK VARCHAR(30),
    I_PARAM VARCHAR(30),
    I_ORDER_NUM SMALLINT,
    I_IS_MAIN_PARAM SMALLINT)
AS
BEGIN
  MERGE INTO UI$BLOCK_REF_PARAM T
    USING (SELECT NULL V FROM RDB$DATABASE)
    ON (T.REF = :I_REF AND T."BLOCK" = :I_BLOCK AND T.PARAM = :I_PARAM)
    WHEN MATCHED THEN UPDATE SET
      T.ORDER_NUM = :I_ORDER_NUM,
      T.IS_MAIN_PARAM = :I_IS_MAIN_PARAM
    WHEN NOT MATCHED THEN INSERT (REF,BLOCK,PARAM,ORDER_NUM,IS_MAIN_PARAM)
  VALUES  (:I_REF,:I_BLOCK,:I_PARAM,:I_ORDER_NUM,:I_IS_MAIN_PARAM);
/*
  UPDATE UI$BLOCK_REF_PARAM T
  SET T.ORDER_NUM=:I_ORDER_NUM,T.IS_MAIN_PARAM=:I_IS_MAIN_PARAM
  WHERE T.REF=:I_REF AND T.BLOCK=:I_BLOCK AND T.PARAM=:I_PARAM AND 1=1;
*/
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_REF_UPD (
    I_ID INTEGER,
    I_BLOCK VARCHAR(30),
    I_REFS_TO VARCHAR(30))
AS
 BEGIN
  UPDATE UI$BLOCK_REF T
  SET T.REFS_TO=:I_REFS_TO
  WHERE T.ID=:I_ID AND T.BLOCK=:I_BLOCK AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_TYPE_CR (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100))
AS
 BEGIN
  FOR
    SELECT T.ID,T.NAME
    FROM UI$BLOCK_TYPE T     
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      1=1
    INTO :ID,:NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$BLOCK_UPD (
    I_ID VARCHAR(30),
    I_BLOCK_TYPE VARCHAR(30),
    I_NAME VARCHAR(100),
    I_CUSTOM_CLASS VARCHAR(100),
    I_IS_MODAL SMALLINT)
AS
 BEGIN
  UPDATE UI$BLOCK T
  SET T.BLOCK_TYPE=:I_BLOCK_TYPE,T.NAME=:I_NAME,T.CUSTOM_CLASS=:I_CUSTOM_CLASS,T.IS_MODAL=:I_IS_MODAL
  WHERE T.ID=:I_ID AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$CR_ACTION_BIND
RETURNS (
    "BLOCK" D_IDENT,
    "ACTION" D_IDENT,
    PARAM D_IDENT,
    DESTINATION_PARAM D_IDENT)
AS
begin
  for
    select b."BLOCK", b."ACTION", b.param, b.destination_param
    from ui$action_bind b
    order by b."BLOCK", b."ACTION", b.param
    into :"BLOCK", :"ACTION", :param, :destination_param
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE UI$CR_BLOCK
RETURNS (
    ID D_IDENT,
    BLOCK_TYPE D_IDENT,
    NAME D_NAME,
    CUSTOM_CLASS D_NAME,
    IS_MODAL D_BOOLEAN)
AS
begin
  for
    select b.id, b.block_type, b.name, b.custom_class, b.is_modal
    from ui$block b
    into :id, :block_type, :name, :custom_class, :is_modal
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE UI$CR_BLOCK_ACTION
RETURNS (
    ID D_IDENT,
    "BLOCK" D_IDENT,
    CAPTION D_NAME,
    LINKS_TO D_IDENT,
    ACTION_STYLE D_IDENT,
    IMAGE_INDEX INTEGER,
    REFRESH_MODE D_IDENT,
    ORDER_NUM SMALLINT)
AS
begin
  for
    select
      a.id, a."BLOCK", a.caption, a.links_to, a.action_style, a.image_index,
      a.refresh_mode, a.order_num
    from ui$block_action a
    order by a."BLOCK", a.order_num
    into
      :id, :"BLOCK", :caption, :links_to, :action_style, :image_index,
      :refresh_mode, :order_num
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE UI$CR_BLOCK_PARAM
RETURNS (
    "BLOCK" D_IDENT,
    PARAM D_IDENT,
    PARAM_DIRECTION D_IDENT,
    DATA_TYPE D_IDENT,
    GROUP_NAME D_NAME,
    ENABLER_PARAM D_IDENT,
    CAPTION D_NAME,
    VISIBLE D_BOOLEAN,
    REQUIRED D_BOOLEAN,
    READ_ONLY D_BOOLEAN,
    SOURCE_CHILD INTEGER,
    SOURCE_PARAM D_IDENT,
    INDEX_IN_KEY SMALLINT,
    INDEX_IN_PARENT SMALLINT,
    INDEX_IN_NAME SMALLINT,
    ORDER_NUM SMALLINT,
    CALL_ORDER_NUM SMALLINT)
AS
begin
  for
    select
      p."BLOCK", p.param, p.param_direction, p.data_type,
      p.group_name, p.caption, p.enabler_param,
      p.visible, p.required, p.read_only,
      p.SOURCE_CHILD, p.source_param,
      p.index_in_key, p.index_in_parent, p.index_in_name,
      p.order_num, p.call_order_num
    from ui$block_param p
    order by p."BLOCK", p.order_num
    into
      :"BLOCK", :param, :param_direction, :data_type,
      :group_name, :caption, :enabler_param,
      :visible, :required, :read_only,
      :SOURCE_CHILD, :source_param,
      :index_in_key, :index_in_parent, :index_in_name,
      :order_num, :call_order_num
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE UI$CR_BLOCK_REF_BIND
RETURNS (
    REF INTEGER,
    DESTINATION_PARAM D_IDENT,
    SOURCE_PARAM D_IDENT)
AS
begin
  for
    select b.ref, b.destination_param, b.source_param
    from UI$BLOCK_REF_BIND B
    order by b.ref, b.destination_param
    into :ref, :destination_param, :source_param
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE UI$CR_BLOCK_REF_PARAM
RETURNS (
    REF INTEGER,
    "BLOCK" D_IDENT,
    REFS_TO D_IDENT,
    PARAM D_IDENT,
    ORDER_NUM SMALLINT,
    IS_MAIN_PARAM D_BOOLEAN)
AS
BEGIN
  FOR
    SELECT
      RP.REF, RP."BLOCK", R.REFS_TO, RP.PARAM, RP.ORDER_NUM, RP.IS_MAIN_PARAM
    FROM UI$BLOCK_REF R
    JOIN UI$BLOCK_REF_PARAM RP ON RP.REF = R.ID AND RP."BLOCK" = R."BLOCK"
    ORDER BY R."BLOCK", R.ID, RP.ORDER_NUM
    INTO :REF, :"BLOCK", :REFS_TO, :PARAM, :ORDER_NUM, :IS_MAIN_PARAM
  DO
    SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$CR_FORM
RETURNS (
    ID D_IDENT,
    MAIN_PROCEDURE D_IDENT,
    HEADER_VISIBLE D_BOOLEAN)
AS
begin
  for
    select f.id, f.main_procedure, f.header_visible
    from ui$form f
    order by f.id
    into :id, :main_procedure, :header_visible
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE UI$CR_FORM_CHILD
RETURNS (
    ID INTEGER,
    FORM D_IDENT,
    "BLOCK" D_IDENT,
    CAPTION D_NAME,
    PANEL INTEGER,
    ORDER_NUM SMALLINT,
    PARAM_GROUP_ALIGN D_IDENT,
    PARAM_ALIGN D_IDENT,
    VISIBLE D_BOOLEAN)
AS
begin
  for
    select
      c.id, p.form, c.block, coalesce(c.caption, b.name), c.panel, c.order_num,
      c.param_group_align, c.param_align, c.visible
    from ui$form_child c
    join ui$form_panel p on p.id = c.panel
    join ui$block b on b.id = c.block
    order by p.form, c.panel, c.order_num
    into
      :id, :form, :block, :caption, :panel, :order_num,
      :param_group_align, :param_align, :visible
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE UI$CR_FORM_CHILD_PARAM
RETURNS (
    FORM_CHILD INTEGER,
    PARAM D_IDENT,
    VISIBLE D_BOOLEAN,
    READ_ONLY D_BOOLEAN,
    REQUIRED D_BOOLEAN,
    SOURCE_CHILD INTEGER,
    SOURCE_PARAM D_IDENT,
    AUTO_REFRESH D_BOOLEAN)
AS
begin
  for
    select
      cp.form_child, cp.param,
      coalesce(cp.visible, p.visible),
      coalesce(cp.read_only, p.read_only),
      coalesce(cp.required, p.required),
      cp.source_child, cp.source_param, cp.auto_refresh
    from ui$form_child_param cp
    join ui$form_child c on c.id = cp.form_child
    join ui$block_param p on p."BLOCK" = c."BLOCK" and p.param = cp.param
    order by cp.form_child, cp.param
    into
      :form_child, :param, :visible, :read_only, :required,
      :source_child, :source_param, :auto_refresh
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE UI$CR_FORM_CHILD_REF_BIND
RETURNS (
    FORM_CHILD INTEGER,
    REF INTEGER,
    DESTINATION_PARAM D_IDENT,
    SOURCE_CHILD INTEGER,
    SOURCE_PARAM D_IDENT)
AS
begin
  for
    select
      b.form_child, b.ref, b.destination_param, b.source_child, b.source_param
    from ui$form_child_ref_bind b
    order by b.form_child, b.ref
    into :form_child, :ref, :destination_param, :source_child, :source_param
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE UI$CR_FORM_PANEL
RETURNS (
    ID INTEGER,
    FORM D_IDENT,
    CAPTION D_NAME,
    PARENT INTEGER,
    ALIGN D_IDENT,
    INDEX_ON_PARENT SMALLINT)
AS
begin
  for
    select p.id, p.form, p.caption, p.parent, p.align, p.index_on_parent
    from ui$form_panel p
    order by p.form, p.id
    into :id, :form, :caption, :parent, :align, :index_on_parent
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE UI$CR_PROCEDURE
RETURNS (
    ID D_IDENT,
    PROCEDURE_NAME D_IDENT)
AS
begin
  for
    select p.id, p.procedure_name
    from ui$procedure p
    into :id, :procedure_name
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE UI$DATA_TYPE_CR (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100))
AS
 BEGIN
  FOR
    SELECT T.ID,T.NAME
    FROM UI$DATA_TYPE T     
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      1=1
    INTO :ID,:NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_CR (
    I_ID INTEGER,
    I_FORM D_IDENT,
    I_PANEL INTEGER = null)
RETURNS (
    ID INTEGER,
    PANEL INTEGER,
    L_PANEL_CAPTION VARCHAR(100),
    "BLOCK" VARCHAR(30),
    CAPTION D_NAME,
    ORDER_NUM SMALLINT,
    PARAM_GROUP_ALIGN VARCHAR(30),
    PARAM_ALIGN VARCHAR(30),
    VISIBLE SMALLINT,
    L_BLOCK_NAME VARCHAR(100),
    L_PARAM_GROUP_ALIGN_NAME VARCHAR(100),
    L_PARAM_ALIGN_NAME VARCHAR(100))
AS
BEGIN
  FOR
    SELECT T.ID,T.PANEL,L_1.CAPTION L_PANEL_CAPTION, T.BLOCK,T.ORDER_NUM,T.PARAM_GROUP_ALIGN,T.PARAM_ALIGN,T.VISIBLE,L_2.NAME AS L_BLOCK_NAME,L_3.NAME AS L_PARAM_GROUP_ALIGN_NAME,L_4.NAME AS L_PARAM_ALIGN_NAME, T.caption
    FROM UI$FORM_CHILD T
    JOIN UI$FORM_PANEL L_1 ON L_1.id = T.PANEL
    LEFT JOIN UI$BLOCK L_2 ON L_2.ID = T.BLOCK
    LEFT JOIN UI$PARAM_ALIGN L_3 ON L_3.ID = T.PARAM_GROUP_ALIGN
    LEFT JOIN UI$PARAM_ALIGN L_4 ON L_4.ID = T.PARAM_ALIGN
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      (:I_FORM IS NULL OR L_1.FORM = :I_FORM) AND
      (:I_PANEL IS NULL OR T.PANEL = :I_PANEL) AND
      1=1
    INTO :ID,:PANEL,:L_PANEL_CAPTION,:BLOCK,:ORDER_NUM,:PARAM_GROUP_ALIGN,:PARAM_ALIGN,:VISIBLE,:L_BLOCK_NAME,:L_PARAM_GROUP_ALIGN_NAME,:L_PARAM_ALIGN_NAME, :CAPTION
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_CR_D (
    I_ID INTEGER)
RETURNS (
    ID INTEGER,
    PANEL INTEGER,
    "BLOCK" VARCHAR(30),
    CAPTION VARCHAR(100),
    ORDER_NUM SMALLINT,
    PARAM_GROUP_ALIGN VARCHAR(30),
    PARAM_ALIGN VARCHAR(30),
    VISIBLE SMALLINT)
AS
 BEGIN
  FOR
    SELECT T.ID,T.PANEL,T.BLOCK,T.ORDER_NUM,T.PARAM_GROUP_ALIGN,T.PARAM_ALIGN,T.VISIBLE, T.CAPTION
    FROM UI$FORM_CHILD T 
    WHERE
      T.ID = :I_ID AND
      1=1
    INTO :ID,:PANEL,:BLOCK,:ORDER_NUM,:PARAM_GROUP_ALIGN,:PARAM_ALIGN,:VISIBLE, :CAPTION
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_DEL (
    I_ID INTEGER,
    I_PANEL INTEGER,
    I_BLOCK VARCHAR(30),
    I_ORDER_NUM SMALLINT,
    I_PARAM_GROUP_ALIGN VARCHAR(30),
    I_PARAM_ALIGN VARCHAR(30),
    I_VISIBLE SMALLINT)
AS
 BEGIN
  DELETE FROM UI$FORM_CHILD T
  WHERE T.ID=:I_ID AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_INS (
    I_ID INTEGER,
    I_PANEL INTEGER,
    I_BLOCK VARCHAR(30),
    I_CAPTION D_NAME,
    I_ORDER_NUM SMALLINT,
    I_PARAM_GROUP_ALIGN VARCHAR(30),
    I_PARAM_ALIGN VARCHAR(30),
    I_VISIBLE SMALLINT)
AS
  DECLARE VARIABLE L_FORM D_IDENT;
BEGIN
  SELECT P.FORM
    FROM UI$FORM_PANEL P
    WHERE P.ID = :I_PANEL
    INTO :L_FORM;

  INSERT INTO UI$FORM_CHILD (ID,FORM,PANEL,BLOCK,ORDER_NUM,PARAM_GROUP_ALIGN,PARAM_ALIGN,VISIBLE, CAPTION)
    VALUES (:I_ID,:L_FORM,:I_PANEL,:I_BLOCK,:I_ORDER_NUM,:I_PARAM_GROUP_ALIGN,:I_PARAM_ALIGN,:I_VISIBLE, :I_CAPTION);
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_PARAM_CR (
    I_FORM_CHILD INTEGER,
    I_PARAM VARCHAR(30))
RETURNS (
    FORM_CHILD INTEGER,
    PARAM VARCHAR(30),
    VISIBLE SMALLINT,
    REQUIRED SMALLINT,
    READ_ONLY SMALLINT,
    SOURCE_CHILD INTEGER,
    SOURCE_PARAM VARCHAR(30),
    AUTO_REFRESH SMALLINT,
    L_FORM_CHILD_ID INTEGER,
    L_SOURCE_BLOCK_ID INTEGER)
AS
BEGIN
  FOR
    SELECT :I_FORM_CHILD,P.PARAM,T.VISIBLE,T.REQUIRED,T.READ_ONLY,T.SOURCE_CHILD,T.SOURCE_PARAM,T.AUTO_REFRESH,L1.ID AS L_FORM_CHILD_ID,L2.ID AS L_SOURCE_BLOCK_ID
    FROM UI$FORM_CHILD C
    JOIN UI$BLOCK_PARAM P ON P.BLOCK = C."BLOCK"
    LEFT JOIN UI$FORM_CHILD_PARAM T ON T.FORM_CHILD = :I_FORM_CHILD AND T.param = P.param
    LEFT JOIN UI$FORM_CHILD L1 ON L1.ID=T.FORM_CHILD
    LEFT JOIN UI$FORM_CHILD L2 ON L2.ID=T.SOURCE_CHILD
    WHERE
      C.ID = :I_FORM_CHILD AND
      (T.PARAM = :I_PARAM OR :I_PARAM IS NULL) AND
      1=1
    INTO :FORM_CHILD,:PARAM,:VISIBLE,:REQUIRED,:READ_ONLY,:SOURCE_CHILD,:SOURCE_PARAM,:AUTO_REFRESH,:L_FORM_CHILD_ID,:L_SOURCE_BLOCK_ID
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_PARAM_CR_D (
    I_FORM_CHILD INTEGER,
    I_PARAM VARCHAR(30))
RETURNS (
    FORM_CHILD INTEGER,
    PARAM VARCHAR(30),
    VISIBLE SMALLINT,
    REQUIRED SMALLINT,
    READ_ONLY SMALLINT,
    SOURCE_CHILD INTEGER,
    SOURCE_PARAM VARCHAR(30),
    AUTO_REFRESH SMALLINT)
AS
BEGIN
  FOR
    SELECT :i_form_child,:i_PARAM,T.VISIBLE,T.REQUIRED,T.READ_ONLY,T.SOURCE_CHILD,T.SOURCE_PARAM,T.AUTO_REFRESH
    FROM UI$FORM_CHILD C
    LEFT JOIN UI$FORM_CHILD_PARAM T ON T.FORM_CHILD = :I_FORM_CHILD AND T.PARAM = :I_PARAM
    WHERE
      C.ID = :I_FORM_CHILD AND
      1=1
    INTO :FORM_CHILD,:PARAM,:VISIBLE,:REQUIRED,:READ_ONLY,:SOURCE_CHILD,:SOURCE_PARAM,:AUTO_REFRESH
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_PARAM_DEL (
    I_FORM_CHILD INTEGER,
    I_PARAM VARCHAR(30))
AS
 BEGIN
  DELETE FROM UI$FORM_CHILD_PARAM T
  WHERE T.FORM_CHILD=:I_FORM_CHILD AND T.PARAM=:I_PARAM AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_PARAM_UPD (
    I_FORM_CHILD INTEGER,
    I_PARAM VARCHAR(30),
    I_VISIBLE SMALLINT,
    I_REQUIRED SMALLINT,
    I_READ_ONLY SMALLINT,
    I_SOURCE_CHILD INTEGER,
    I_SOURCE_PARAM VARCHAR(30),
    I_AUTO_REFRESH SMALLINT)
AS
  DECLARE VARIABLE L_SOURCE_BLOCK D_IDENT;
  DECLARE VARIABLE L_CHILD_BLOCK D_IDENT;
  DECLARE VARIABLE L_CHILD_FORM D_IDENT;
BEGIN
  SELECT C."BLOCK"
    FROM UI$FORM_CHILD C
    WHERE C.ID = :I_SOURCE_CHILD
    INTO :L_SOURCE_BLOCK;

  SELECT C.FORM, C.BLOCK
    FROM UI$FORM_CHILD C
    WHERE C.ID = :I_FORM_CHILD
    INTO :L_CHILD_FORM, :L_CHILD_BLOCK;

  MERGE INTO UI$FORM_CHILD_PARAM P
    USING (SELECT NULL V FROM RDB$DATABASE)
    ON (P.FORM_CHILD=:I_FORM_CHILD AND P.PARAM=:I_PARAM)
    WHEN MATCHED THEN
      UPDATE SET
        P.VISIBLE=:I_VISIBLE,P.REQUIRED=:I_REQUIRED,P.READ_ONLY=:I_READ_ONLY,
        P.SOURCE_BLOCK = :L_SOURCE_BLOCK,P.SOURCE_CHILD=:I_SOURCE_CHILD,P.SOURCE_PARAM=:I_SOURCE_PARAM,
        P.AUTO_REFRESH=:I_AUTO_REFRESH
    WHEN NOT MATCHED THEN INSERT (
        FORM_CHILD,FORM,BLOCK,PARAM,VISIBLE,
        REQUIRED,READ_ONLY,AUTO_REFRESH,
        SOURCE_BLOCK, SOURCE_CHILD,SOURCE_PARAM)
      VALUES (
        :I_FORM_CHILD,:L_CHILD_FORM, :L_CHILD_BLOCK, :I_PARAM,:I_VISIBLE,
        :I_REQUIRED,:I_READ_ONLY,:I_AUTO_REFRESH,
        :L_SOURCE_BLOCK, :I_SOURCE_CHILD,:I_SOURCE_PARAM
      );
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_REF_BIND_CR (
    I_FORM_CHILD INTEGER,
    I_REF INTEGER,
    I_DESTINATION_PARAM VARCHAR(30))
RETURNS (
    FORM_CHILD INTEGER,
    FORM VARCHAR(30),
    "BLOCK" VARCHAR(30),
    REF INTEGER,
    DESTINATION_PARAM VARCHAR(30),
    SOURCE_CHILD INTEGER,
    SOURCE_BLOCK VARCHAR(30),
    SOURCE_PARAM VARCHAR(30),
    L_1_FORM_CHILD_ID INTEGER,
    L_1_FORM_ID INTEGER,
    L_1_BLOCK_ID INTEGER,
    L_3_SOURCE_CHILD_ID INTEGER,
    L_3_FORM_ID INTEGER,
    L_3_SOURCE_BLOCK_ID INTEGER)
AS
 BEGIN
  FOR
    SELECT T.FORM_CHILD,T.FORM,T.BLOCK,T.REF,T.DESTINATION_PARAM,T.SOURCE_CHILD,T.SOURCE_BLOCK,T.SOURCE_PARAM,L1.ID AS L_1_FORM_CHILD_ID,L1.ID AS L_1_FORM_ID,L1.ID AS L_1_BLOCK_ID,L3.ID AS L_3_SOURCE_CHILD_ID,L3.ID AS L_3_FORM_ID,L3.ID AS L_3_SOURCE_BLOCK_ID
    FROM UI$FORM_CHILD_REF_BIND T     
    LEFT JOIN UI$FORM_CHILD L1 ON L1.ID=T.FORM_CHILD AND L1.FORM=T.FORM AND L1.BLOCK=T.BLOCK
    LEFT JOIN UI$BLOCK_PARAM L2 ON L2.BLOCK=T.SOURCE_BLOCK AND L2.PARAM=T.SOURCE_PARAM
    LEFT JOIN UI$FORM_CHILD L3 ON L3.ID=T.SOURCE_CHILD AND L3.FORM=T.FORM AND L3.BLOCK=T.SOURCE_BLOCK
    LEFT JOIN UI$BLOCK_REF L4 ON L4.ID=T.REF AND L4.BLOCK=T.BLOCK
    WHERE
      (T.FORM_CHILD = :I_FORM_CHILD OR :I_FORM_CHILD IS NULL) AND
      (T.REF = :I_REF OR :I_REF IS NULL) AND
      (T.DESTINATION_PARAM = :I_DESTINATION_PARAM OR :I_DESTINATION_PARAM IS NULL) AND
      1=1
    INTO :FORM_CHILD,:FORM,:BLOCK,:REF,:DESTINATION_PARAM,:SOURCE_CHILD,:SOURCE_BLOCK,:SOURCE_PARAM,:L_1_FORM_CHILD_ID,:L_1_FORM_ID,:L_1_BLOCK_ID,:L_3_SOURCE_CHILD_ID,:L_3_FORM_ID,:L_3_SOURCE_BLOCK_ID
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_REF_BIND_CR_D (
    I_FORM_CHILD INTEGER,
    I_REF INTEGER,
    I_DESTINATION_PARAM VARCHAR(30))
RETURNS (
    FORM_CHILD INTEGER,
    FORM VARCHAR(30),
    "BLOCK" VARCHAR(30),
    REF INTEGER,
    DESTINATION_PARAM VARCHAR(30),
    SOURCE_CHILD INTEGER,
    SOURCE_BLOCK VARCHAR(30),
    SOURCE_PARAM VARCHAR(30))
AS
 BEGIN
  FOR
    SELECT T.FORM_CHILD,T.FORM,T.BLOCK,T.REF,T.DESTINATION_PARAM,T.SOURCE_CHILD,T.SOURCE_BLOCK,T.SOURCE_PARAM
    FROM UI$FORM_CHILD_REF_BIND T 
    WHERE
      T.FORM_CHILD = :I_FORM_CHILD AND
      T.REF = :I_REF AND
      T.DESTINATION_PARAM = :I_DESTINATION_PARAM AND
      1=1
    INTO :FORM_CHILD,:FORM,:BLOCK,:REF,:DESTINATION_PARAM,:SOURCE_CHILD,:SOURCE_BLOCK,:SOURCE_PARAM
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_REF_BIND_DEL (
    I_FORM_CHILD INTEGER,
    I_FORM VARCHAR(30),
    I_BLOCK VARCHAR(30),
    I_REF INTEGER,
    I_DESTINATION_PARAM VARCHAR(30),
    I_SOURCE_CHILD INTEGER,
    I_SOURCE_BLOCK VARCHAR(30),
    I_SOURCE_PARAM VARCHAR(30))
AS
 BEGIN
  DELETE FROM UI$FORM_CHILD_REF_BIND T
  WHERE T.FORM_CHILD=:I_FORM_CHILD AND T.REF=:I_REF AND T.DESTINATION_PARAM=:I_DESTINATION_PARAM AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_REF_BIND_INS (
    I_FORM_CHILD INTEGER,
    I_FORM VARCHAR(30),
    I_BLOCK VARCHAR(30),
    I_REF INTEGER,
    I_DESTINATION_PARAM VARCHAR(30),
    I_SOURCE_CHILD INTEGER,
    I_SOURCE_BLOCK VARCHAR(30),
    I_SOURCE_PARAM VARCHAR(30))
AS
 BEGIN
  INSERT INTO UI$FORM_CHILD_REF_BIND (FORM_CHILD,FORM,BLOCK,REF,DESTINATION_PARAM,SOURCE_CHILD,SOURCE_BLOCK,SOURCE_PARAM)
  VALUES  (:I_FORM_CHILD,:I_FORM,:I_BLOCK,:I_REF,:I_DESTINATION_PARAM,:I_SOURCE_CHILD,:I_SOURCE_BLOCK,:I_SOURCE_PARAM);
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_REF_BIND_UPD (
    I_FORM_CHILD INTEGER,
    I_FORM VARCHAR(30),
    I_BLOCK VARCHAR(30),
    I_REF INTEGER,
    I_DESTINATION_PARAM VARCHAR(30),
    I_SOURCE_CHILD INTEGER,
    I_SOURCE_BLOCK VARCHAR(30),
    I_SOURCE_PARAM VARCHAR(30))
AS
 BEGIN
  UPDATE UI$FORM_CHILD_REF_BIND T
  SET T.FORM=:I_FORM,T.BLOCK=:I_BLOCK,T.SOURCE_CHILD=:I_SOURCE_CHILD,T.SOURCE_BLOCK=:I_SOURCE_BLOCK,T.SOURCE_PARAM=:I_SOURCE_PARAM
  WHERE T.FORM_CHILD=:I_FORM_CHILD AND T.REF=:I_REF AND T.DESTINATION_PARAM=:I_DESTINATION_PARAM AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CHILD_UPD (
    I_ID INTEGER,
    I_PANEL INTEGER,
    I_BLOCK VARCHAR(30),
    I_CAPTION VARCHAR(100),
    I_ORDER_NUM SMALLINT,
    I_PARAM_GROUP_ALIGN VARCHAR(30),
    I_PARAM_ALIGN VARCHAR(30),
    I_VISIBLE SMALLINT)
AS
 BEGIN
  UPDATE UI$FORM_CHILD T
  SET
    T.PANEL=:I_PANEL,T.BLOCK=:I_BLOCK,T.ORDER_NUM=:I_ORDER_NUM,
    T.PARAM_GROUP_ALIGN=:I_PARAM_GROUP_ALIGN,T.PARAM_ALIGN=:I_PARAM_ALIGN,
    T.CAPTION = :I_CAPTION, T.VISIBLE=:I_VISIBLE
  WHERE T.ID=:I_ID AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CR (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100),
    MAIN_PROCEDURE VARCHAR(30),
    MAIN_PROCEDURE_NAME VARCHAR(100),
    CUSTOM_CLASS VARCHAR(100),
    IS_MODAL SMALLINT)
AS
BEGIN
  FOR
    SELECT
      T.ID, L_1.NAME, L_1.CUSTOM_CLASS,
      L_1.IS_MODAL, T.MAIN_PROCEDURE, L_2.NAME MAIN_PROCEDURE_NAME
    FROM UI$FORM T
    JOIN UI$BLOCK L_1 ON L_1.ID = T.ID
    LEFT JOIN UI$BLOCK L_2 ON L_2.ID = T.MAIN_PROCEDURE
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      1=1
    order by t.id
    INTO
      :ID, :NAME, :CUSTOM_CLASS,
      :IS_MODAL, :MAIN_PROCEDURE, :MAIN_PROCEDURE_NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$FORM_CR_D (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100),
    MAIN_PROCEDURE VARCHAR(30),
    CUSTOM_CLASS VARCHAR(100),
    IS_MODAL SMALLINT)
AS
BEGIN
  FOR
    SELECT
      T.ID, L_1.NAME, L_1.CUSTOM_CLASS,
      L_1.IS_MODAL, T.MAIN_PROCEDURE
    FROM UI$FORM T
    JOIN UI$BLOCK L_1 ON L_1.ID = T.ID
    WHERE
      T.ID = :I_ID AND
      1=1
    INTO
      :ID, :NAME, :CUSTOM_CLASS,
      :IS_MODAL, :MAIN_PROCEDURE
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$FORM_DEL (
    I_ID VARCHAR(30))
AS
BEGIN
/*
  delete from ui$block_param p
    where p."BLOCK" = :i_id;
 */
  delete from ui$block b
    where b.id = :i_id;
END^


CREATE OR ALTER PROCEDURE UI$FORM_INS (
    I_ID VARCHAR(30),
    I_MAIN_PROCEDURE VARCHAR(30),
    I_NAME VARCHAR(100),
    I_CUSTOM_CLASS VARCHAR(100),
    I_IS_MODAL SMALLINT)
AS
BEGIN
  INSERT INTO UI$FORM (ID,MAIN_PROCEDURE)
    VALUES (:I_ID,:I_MAIN_PROCEDURE);
  INSERT INTO UI$BLOCK (ID, NAME, CUSTOM_CLASS, IS_MODAL)
    VALUES (:I_ID, :I_NAME, :I_CUSTOM_CLASS, :I_IS_MODAL);
END^


CREATE OR ALTER PROCEDURE UI$FORM_PANEL_CR (
    I_ID INTEGER,
    I_FORM D_IDENT)
RETURNS (
    ID INTEGER,
    FORM VARCHAR(30),
    CAPTION VARCHAR(100),
    PARENT INTEGER,
    ALIGN VARCHAR(30),
    INDEX_ON_PARENT INTEGER,
    L_ALIGN_NAME VARCHAR(100))
AS
BEGIN
  FOR
    SELECT T.ID,T.FORM,T.CAPTION,T.PARENT,T.ALIGN,T.INDEX_ON_PARENT,L_3.NAME AS L_ALIGN_NAME
    FROM UI$FORM_PANEL T
    LEFT JOIN UI$FORM L_1 ON L_1.ID = T.FORM
    LEFT JOIN UI$FORM_PANEL L_2 ON L_2.ID = T.PARENT
    LEFT JOIN UI$PANEL_ALIGN L_3 ON L_3.ID = T.ALIGN
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      (:I_FORM IS NULL OR T.FORM = :I_FORM) AND
      1=1
    INTO :ID,:FORM,:CAPTION,:PARENT,:ALIGN,:INDEX_ON_PARENT,:L_ALIGN_NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$FORM_PANEL_CR_D (
    I_ID INTEGER)
RETURNS (
    ID INTEGER,
    FORM VARCHAR(30),
    CAPTION VARCHAR(100),
    PARENT INTEGER,
    ALIGN VARCHAR(30),
    INDEX_ON_PARENT INTEGER)
AS
 BEGIN
  FOR
    SELECT T.ID,T.FORM,T.CAPTION,T.PARENT,T.ALIGN,T.INDEX_ON_PARENT
    FROM UI$FORM_PANEL T 
    WHERE
      T.ID = :I_ID AND
      1=1
    INTO :ID,:FORM,:CAPTION,:PARENT,:ALIGN,:INDEX_ON_PARENT
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$FORM_PANEL_DEL (
    I_ID INTEGER,
    I_FORM VARCHAR(30),
    I_CAPTION VARCHAR(100),
    I_PARENT INTEGER,
    I_ALIGN VARCHAR(30),
    I_INDEX_ON_PARENT INTEGER)
AS
 BEGIN
  DELETE FROM UI$FORM_PANEL T
  WHERE T.ID=:I_ID AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$FORM_PANEL_INS (
    I_ID INTEGER,
    I_FORM VARCHAR(30),
    I_CAPTION VARCHAR(100),
    I_PARENT INTEGER,
    I_ALIGN VARCHAR(30),
    I_INDEX_ON_PARENT INTEGER)
AS
 BEGIN
  INSERT INTO UI$FORM_PANEL (ID,FORM,CAPTION,PARENT,ALIGN,INDEX_ON_PARENT)
  VALUES  (:I_ID,:I_FORM,:I_CAPTION,:I_PARENT,:I_ALIGN,:I_INDEX_ON_PARENT);
END^


CREATE OR ALTER PROCEDURE UI$FORM_PANEL_UPD (
    I_ID INTEGER,
    I_FORM VARCHAR(30),
    I_CAPTION VARCHAR(100),
    I_PARENT INTEGER,
    I_ALIGN VARCHAR(30),
    I_INDEX_ON_PARENT INTEGER)
AS
BEGIN
  UPDATE UI$FORM_PANEL T
  SET T.CAPTION=:I_CAPTION,T.PARENT=:I_PARENT,T.ALIGN=:I_ALIGN,T.INDEX_ON_PARENT=:I_INDEX_ON_PARENT
  WHERE T.ID=:I_ID AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$FORM_UPD (
    I_ID VARCHAR(30),
    I_MAIN_PROCEDURE VARCHAR(30),
    I_NAME VARCHAR(100),
    I_CUSTOM_CLASS VARCHAR(100),
    I_IS_MODAL SMALLINT)
AS
BEGIN
  UPDATE UI$FORM T
    SET T.MAIN_PROCEDURE = :I_MAIN_PROCEDURE
    WHERE T.ID=:I_ID;

  UPDATE UI$BLOCK B
    SET
      B.NAME = :I_NAME,
      B.CUSTOM_CLASS = :I_CUSTOM_CLASS,
      B.IS_MODAL = :I_IS_MODAL
    WHERE B.ID = :I_ID;
END^


CREATE OR ALTER PROCEDURE UI$GENERATE_BLOCK_BY_PROCEDURE (
    I_PROCEDURE_NAME D_IDENT,
    I_GENERATE_FORM D_BOOLEAN = 0,
    I_MENU_ITEM_PARENT INTEGER = null,
    I_MENU_ITEM_ORDER_NUM SMALLINT = null)
AS
declare variable L_PROCEDURE_DESCRIPTION varchar(1000);
declare variable L_BLOCK_EXISTS D_BOOLEAN;
declare variable L_BLOCK_ID D_IDENT;
begin
  select coalesce(p.rdb$description, p.rdb$procedure_name)
    from rdb$procedures p
    where p.rdb$procedure_name = :i_procedure_name
    into :l_procedure_description;

  select count(*), max(p.id)
    from ui$procedure p
    where p.procedure_name = :i_procedure_name
    into l_block_exists, l_block_id;

  if (l_block_exists = 0) then
  begin
    l_block_id = i_procedure_name || '_P';
    -- процедура
    insert into ui$block (id, block_type, name)
      values (:l_block_id, 'procedure', :l_procedure_description);
    insert into ui$procedure (id, procedure_name)
      values (:l_block_id, :i_procedure_name);
  end
  merge into ui$block_param bp
    using (
      select
        trim(pp.rdb$parameter_name) name,
        trim(case when pp.rdb$parameter_type = 0 then 'in' else 'field' end) direction,
        dt.id data_type,
        trim(coalesce(pp.rdb$description, pp.rdb$parameter_name)) description,
        case when trim(pp.rdb$parameter_name) = 'NAME' then 1 end index_in_name,
        (pp.rdb$parameter_number + 1) * 10 order_num,
        pp.rdb$parameter_number + 1 call_order_num
      from rdb$procedure_parameters pp
      left join rdb$fields f on f.rdb$field_name = pp.rdb$field_source
      left join ui$field_type_fb ft on ft.fb_type_id = f.rdb$field_type
      left join ui$data_type dt on dt.id = ft.data_type
      where
        pp.rdb$procedure_name = :i_procedure_name and
        1=1
    ) p
    on (bp."BLOCK" = :l_block_id and bp.param = p.name)
    when not matched then
      insert ("BLOCK", param, param_direction, data_type, caption, index_in_name, order_num, call_order_num)
      values (:l_block_id, p.name, p.direction, p.data_type, p.description, p.index_in_name, p.order_num, p.call_order_num)
    when matched then update set
      bp.call_order_num = p.call_order_num,
      bp.data_type =
        case
          when bp.data_type = 'boolean' and p.data_type = 'integer' then bp.data_type
          else p.data_type
        end
  ;
  delete from ui$block_param bp
    where
      bp."BLOCK" = :l_block_id and
      bp.param not in (
        select trim(pp.rdb$parameter_name)
        from rdb$procedure_parameters pp
        where
          pp.rdb$procedure_name = :i_procedure_name and
          1=1
      );

  if (i_generate_form = 1) then
    execute procedure ui$generate_form_by_procedure(i_procedure_name);

  if (i_menu_item_parent is not null) then
    execute procedure ui$add_to_menu(
      i_menu_item_parent,
      i_menu_item_order_num,
      case
        when :i_generate_form = 1 then :i_procedure_name || '_FR'
        else :l_block_id
      end
    );
end^


CREATE OR ALTER PROCEDURE UI$GENERATE_EDITOR_FORM (
    I_TABLE_NAME D_IDENT,
    I_ACTION D_IDENT)
AS
declare variable L_ACTION_CODE_NAME D_IDENT;
declare variable L_FORM_NAME D_IDENT;
declare variable L_FORM_DESCRIPTION D_NAME;
declare variable L_DETAIL_CURSOR_NAME D_IDENT;
declare variable L_EDIT_PROCEDURE D_IDENT;
declare variable L_EDIT_PROCEDURE_BLOCK_NAME D_IDENT;
declare variable L_CURSOR_CHILD integer;
declare variable L_EDIT_CHILD integer;
declare variable L_FORM_PANEL integer;
declare variable L_LAST_REF integer;
declare variable L_REF_ID integer;
declare variable L_REF_LINKS_TO D_IDENT;
declare variable L_REF_INDEX smallint;
declare variable L_REF_FIELD D_IDENT;
declare variable L_REF_FIELD_POS smallint;
begin
  select r.rdb$description || ' - ' || a.name, a.name_in_code
    from ui$default_action a
    cross join rdb$relations r
    where
      a.id = :i_action and
      r.rdb$relation_name = :i_table_name and
      1=1
    into :l_form_description, :l_action_code_name;

  l_edit_procedure = i_table_name || '_' || l_action_code_name;
  l_form_name = l_edit_procedure || '_FR';
  l_detail_cursor_name = i_table_name || '_CR_D';
  l_edit_procedure_block_name = i_table_name || '_' || l_action_code_name || '_P';

  -- форма редактирования
  insert into ui$block (id, block_type, name, is_modal)
    values (:l_form_name, 'form', :l_form_description, 0);
  insert into ui$form (id)
    values (:l_form_name);

  -- панель
  insert into ui$form_panel (form, caption, parent, align, index_on_parent)
    values (:l_form_name, :l_form_description, null, 'left', 1)
    returning id into :l_form_panel;

  -- процедура редактирования
  insert into ui$block (id, block_type, name, is_modal)
    values (:l_edit_procedure_block_name, 'procedure', :l_form_description, 1);
  insert into ui$procedure (id, procedure_name)
    values (:l_edit_procedure_block_name, :l_edit_procedure);
  insert into ui$block_param (
      block, param, param_direction, data_type, order_num, caption,
      visible, required, group_name, enabler_param, read_only, call_order_num
    )
    select
      :l_edit_procedure_block_name, 'I_' || f.field_name, 'in',
      f.field_type_name, p.order_num, coalesce(p.caption, f.field_name),
      p.visible, p.required, p.group_name, p.enabler_param, p.required, p.call_order_num
    from ui$block_param p
    join ui$get_table_fields(:i_table_name) f on f.field_name = p.param
    where
      p."BLOCK" = :i_table_name || '_CR' and
      1=1;

  -- блоки - курсор и процедура редактирования
  insert into ui$form_child (form, panel, block, order_num, param_group_align, param_align, visible)
    values (:l_form_name, :l_form_panel, :l_detail_cursor_name, 1, 'horizontal', 'horizontal', 0)
    returning id into :l_cursor_child;
  insert into ui$form_child (form, panel, block, order_num, param_group_align, param_align, visible)
    values (:l_form_name, :l_form_panel, :l_edit_procedure_block_name, 2, 'vertical', 'vertical', 1)
    returning id into :l_edit_child;

  -- входные параметры процедуры - первичный ключ
  insert into ui$block_param (block, param, param_direction, data_type, order_num, source_child, source_param, caption, call_order_num, visible)
    select
      :l_form_name, 'I_' || f.field_name, 'in', f.field_type_name,
      f.index_on_key, :l_cursor_child, 'I_' || f.field_name,
      coalesce(f.field_description, f.field_name),
      f.index_on_key, 0
    from ui$get_table_fields(:i_table_name) f
    where
      f.index_on_key is not null and
      :i_action <> 'insert' and
      1=1;

  -- связи между блоками
  insert into ui$form_child_param (
      form_child, form, block,
      param, read_only,
      source_block, source_child, source_param
    )
    select
      :l_edit_child, :l_form_name, :l_edit_procedure_block_name,
      'I_' || f.field_name, case when :i_action = 'delete' then 1 end,
      :l_detail_cursor_name, :l_cursor_child, f.field_name
    from ui$get_table_fields(:i_table_name) f;

  -- выбор значений из справочников
  l_last_ref = 0;
  for
    select
      l.links_to_procedure, l.link_index,
      l.field_name, l.field_position
    from ui$get_table_links(:i_table_name) l
    into :l_ref_links_to, :l_ref_index, :l_ref_field, :l_ref_field_pos
  do
  begin
    if (l_last_ref <> l_ref_index) then
      insert into ui$block_ref (block, refs_to)
        values (:l_edit_procedure_block_name, :l_ref_links_to)
        returning id into :l_ref_id;
    insert into ui$block_ref_param (ref, block, param, order_num, is_main_param)
      values (:l_ref_id, :l_edit_procedure_block_name, 'I_' || :l_ref_field, :l_ref_field_pos, case when :l_ref_field_pos = 1 then 1 else 0 end);
  end
end^


CREATE OR ALTER PROCEDURE UI$GENERATE_FORM_BY_PROCEDURE (
    I_PROCEDURE_NAME D_IDENT)
AS
declare variable L_PROCEDURE_ID D_IDENT;
declare variable L_FORM_NAME D_IDENT;
declare variable L_PROCEDURE_DESCRIPTION D_NAME;
declare variable L_FORM_PANEL integer;
declare variable L_FORM_CHILD integer;
declare variable L_FORM_EXISTS D_BOOLEAN;
begin
  l_form_name = i_procedure_name || '_FR';

  select count(*)
    from ui$form f
    where f.id = :l_form_name
    into :l_form_exists;

  select max(p.id)
    from ui$procedure p
    where p.procedure_name = :i_procedure_name
    into :l_procedure_id;

  if (l_form_exists = 0) then
  begin
    -- форма
    insert into ui$block (id, block_type, name)
      select :l_form_name, 'form', b.name
      from ui$procedure p
      join ui$block b on b.id = p.id
      where p.procedure_name = :i_procedure_name
      returning name into :l_procedure_description;
    insert into ui$form (id, main_procedure)
      values (:l_form_name, :l_procedure_id);
    insert into ui$form_panel (form, caption, parent, align, index_on_parent)
      values (:l_form_name, :l_procedure_description, null, 'top', 1)
      returning id into :l_form_panel;
    insert into ui$form_child (form, panel, block, order_num, param_group_align, param_align, visible)
      values (:l_form_name, :l_form_panel, :l_procedure_id, 1, 'horizontal', 'horizontal', 1)
      returning id into :l_form_child;
  end
  else
  begin
    select case when count(*) = 1 then min(c.id) end
      from ui$form_panel p
      join ui$form_child c on c.panel = p.id and c."BLOCK" = :l_procedure_id
      where
        p.form = :l_form_name and
        1=1
      into :l_form_child;
  end

  if (l_form_child is not null) then
    delete from ui$block_param bp
      where bp."BLOCK" = :l_form_name;

  insert into ui$block_param (
      block, param, param_direction, data_type, caption, visible,
      source_form, source_block, source_child, source_param,
      index_in_key, index_in_name, order_num, call_order_num)
    select
      :l_form_name, p.param, p.param_direction, p.data_type, p.caption, 0,
      :l_form_name, :l_procedure_id, :l_form_child, p.param,
      p.index_in_key, p.index_in_name, p.order_num, p.call_order_num
    from ui$block_param p
    where p."BLOCK" = :l_procedure_id;
end^


CREATE OR ALTER PROCEDURE UI$GENERATE_FORM_BY_TABLE (
    I_TABLE_NAME D_IDENT,
    I_GENERATE_FORM D_BOOLEAN = 0,
    I_GENERATE_EDITORS D_BOOLEAN = 1,
    I_MENU_ITEM_PARENT INTEGER = null,
    I_MENU_ITEM_ORDER_NUM SMALLINT = null)
RETURNS (
    O_SCRIPT VARCHAR(8000))
AS
declare variable L_FIELD_DATAS varchar(1000);
declare variable L_JOIN_FIELD_DATAS varchar(1000);
declare variable L_FIELDS varchar(1000);
declare variable L_FIELD_PARAMS varchar(1000);
declare variable L_JOIN_FIELD_PARAMS varchar(1000);
declare variable L_IN_PARAMS varchar(1000);
declare variable L_WHERE_ITEM varchar(100);
declare variable L_WHERE varchar(1000);
declare variable L_JOINS varchar(1000);
declare variable L_JOIN_FIELDS varchar(1000);
declare variable L_CRLF varchar(2);
declare variable L_JOIN_INDEX integer;
declare variable L_GRID_CURSOR_NAME varchar(1000);
declare variable L_CONSTRAINT_NAME D_IDENT;
declare variable L_LAST_CONSTRAINT_NAME D_IDENT;
declare variable L_LINK_TABLE D_IDENT;
declare variable L_LINK_FIELD D_IDENT;
declare variable L_FIELD_NAME D_IDENT;
declare variable L_FIELD_TYPE D_NAME;
declare variable L_FIELD_TYPE_D D_IDENT;
declare variable L_FIELD_CAPTION D_NAME;
declare variable L_LINK_FIELD_NAME D_NAME;
declare variable L_CONDITIONS varchar(1000);
declare variable L_LINK_INDEX smallint;
declare variable L_FIELD_INDEX smallint;
declare variable L_EDIT_SCRIPT varchar(4000);
declare variable L_TABLE_DESCRIPTION varchar(1000);
begin
  l_crlf = ascii_char(13) || ascii_char(10);
  l_grid_cursor_name = i_table_name || '_CR';
  o_script = 'SET TERM ^ ;' || l_crlf;

  l_join_fields = '';
  l_join_field_datas = '';
  l_join_field_params = '';

  -- выбираем поля строками полностью
  execute procedure ui$get_table_fields_str(i_table_name, null, 1) returning_values (l_field_datas);
  execute procedure ui$get_table_fields_str(i_table_name, 'T.', 0) returning_values (l_fields);
  execute procedure ui$get_table_fields_str(i_table_name, ':', 0) returning_values (l_field_params);
  execute procedure ui$get_table_fields_str(i_table_name, 'I_', 1, 1) returning_values (l_in_params);

  select r.rdb$description
    from rdb$relations r
    where r.rdb$relation_name = :i_table_name
    into :l_table_description;

  -- процедура грида
  insert into ui$block (id, block_type, name, is_modal)
    values (:l_grid_cursor_name, 'procedure', :l_table_description, 0);
  insert into ui$procedure (id, procedure_name, is_grid_for_table)
    values (:l_grid_cursor_name, :l_grid_cursor_name, :i_table_name);
  insert into ui$block_param (
      block, param, param_direction, data_type,
      caption,
      index_in_key,
      index_in_name,
      call_order_num
    )
    select
      :l_grid_cursor_name, f.field_name,
      'field', dt.id, coalesce(f.field_description, f.field_name),
      f.index_on_key,
      case when f.field_name = 'NAME' then 1 end,
      f.order_num
    from ui$get_table_fields(:i_table_name) f
    left join ui$field_type_fb ff on ff.fb_type_id = f.field_type_fb
    left join ui$data_type dt on dt.id = ff.data_type;

  -- заполняем where
  l_field_index = 1;
  l_where = 'WHERE' || l_crlf;
  for
    select
      '      (T.' || f.field_name || ' = :I_' || f.field_name || ' OR :I_' || f.field_name || ' IS NULL) AND',
      f.field_name, coalesce(f.field_description, f.field_name), f.field_type_name
    from ui$get_table_fields(:i_table_name) f
    where
      f.index_on_key is not null and
      1=1
    order by f.order_num
    into :l_where_item, :l_field_name, :l_field_caption, :l_field_type_d
  do
  begin
    l_where = l_where || l_where_item || l_crlf;
    insert into ui$block_param (block, param, param_direction, data_type, order_num, caption, call_order_num)
      values (:l_grid_cursor_name, 'I_' || :l_field_name, 'in', :l_field_type_d, :l_field_index, :l_field_caption, :l_field_index);
    l_field_index = l_field_index + 1;
  end
  l_where = l_where || '      1=1';

  -- заполняем join-ы к процедурам
  l_joins = '';
  l_conditions = '';
  l_last_constraint_name = '';
  for
    select tl.fk_name, tl.links_to_table, tl.field_name, tl.links_to_field, tl.link_index
    from ui$get_table_links(:i_table_name) tl
    order by tl.link_index, tl.field_position
    into :l_constraint_name, :l_link_table, :l_field_name, :l_link_field, :l_join_index
  do
  begin
    if (l_last_constraint_name <> l_constraint_name) then
    begin
      if (l_joins <> '') then
        l_joins = l_joins || ' L' || (l_join_index - 1) || ' ON ' || substring(l_conditions from 1 for char_length(l_conditions) - 5);
      l_joins = l_joins || l_crlf || '    LEFT JOIN ' || l_link_table;
      l_last_constraint_name = l_constraint_name;
      l_conditions = '';
    end
    l_conditions = l_conditions ||
      'L' || l_join_index || '.' || l_link_field ||
      '=T.' || l_field_name || ' AND ';
  end
  if (l_last_constraint_name <> '') then
    l_joins = l_joins || ' L' || l_join_index || ' ON ' || substring(l_conditions from 1 for char_length(l_conditions) - 5);

  -- заполняем поля расшифровки
  l_join_fields = '';
  l_last_constraint_name = '';
  for
    select
      tl.fk_name, tl.field_name, lp.param, lp.index_in_name,
      f.field_type, f.field_type_name, p.caption, tl.link_index
    from ui$get_table_links(:i_table_name) tl
    join ui$procedure b on b.is_grid_for_table = :i_table_name
    join ui$block_param p on p."BLOCK" = b.id and p.param = tl.field_name
    join ui$block_param lp on
      lp."BLOCK" = tl.links_to_procedure and
      lp.param_direction = 'field' and
      lp.index_in_name is not null and
      1=1
    join ui$get_table_fields(tl.links_to_table) f on f.field_name = lp.param
    where
      tl.links_to_procedure is not null and
      1=1
    order by tl.link_index, tl.field_position, lp.index_in_name
    into
      :l_constraint_name, :l_field_name, :l_link_field,
      :l_field_index, :l_field_type, :l_field_type_d, :l_field_caption, :l_link_index
  do
  begin
    l_link_field_name = 'L_' || l_link_index || '_' || l_field_name || '_' || l_link_field;
    l_join_fields = l_join_fields ||
      ',L' || l_link_index || '.' || l_link_field || ' AS ' || l_link_field_name;
    l_join_field_datas = l_join_field_datas || ',' || l_link_field_name || ' ' || l_field_type;
    l_join_field_params = l_join_field_params || ',:' || l_link_field_name;
    insert into ui$block_param (block, param, param_direction, data_type, caption)
      values (:l_grid_cursor_name, :l_link_field_name, 'field', :l_field_type_d, :l_field_caption || case when :l_field_index > 1 then :l_field_index else '' end);
  end

  -- форма
  if (i_generate_form = 1) then
    execute procedure ui$generate_form_by_procedure(l_grid_cursor_name);

  -- меню
  if (i_menu_item_parent is not null) then
    execute procedure ui$add_to_menu(
      i_menu_item_parent,
      i_menu_item_order_num,
      case
        when :i_generate_form = 1 then :l_grid_cursor_name || '_FR'
        else :l_grid_cursor_name
      end
    );

  -- курсор для показа таблицы
  o_script = o_script || 'CREATE OR ALTER PROCEDURE ' || l_grid_cursor_name || l_crlf;

  o_script = o_script || '(' || l_in_params || ') RETURNS (' || l_crlf;
  o_script = o_script || '  ' || l_field_datas || l_join_field_datas || l_crlf;
  o_script = o_script || ') AS BEGIN' || l_crlf;
  o_script = o_script || '  FOR' || l_crlf;
  o_script = o_script || '    SELECT ' || l_fields || l_join_fields || l_crlf;
  o_script = o_script || '    FROM ' || i_table_name || ' T ';
  o_script = o_script || '    ' || l_joins || l_crlf;
  o_script = o_script || '    ' || l_where || l_crlf;
  o_script = o_script || '    INTO ' || l_field_params || l_join_field_params || l_crlf;
  o_script = o_script || '  DO SUSPEND;' || l_crlf;
  o_script = o_script || 'END^' || l_crlf;

  -- процедуры и формы редактирования
  if (i_generate_editors = 1) then
  begin
    execute procedure ui$generate_table_editors(i_table_name, 0)
      returning_values (l_edit_script);
    o_script = o_script || l_edit_script || l_crlf;
  end

  o_script = o_script || 'SET TERM ; ^' || l_crlf;

end^


CREATE OR ALTER PROCEDURE UI$GENERATE_TABLE_EDITORS (
    I_TABLE_NAME D_IDENT,
    I_INCLUDE_TERM D_BOOLEAN = 1)
RETURNS (
    O_SCRIPT VARCHAR(8000))
AS
declare variable L_GRID_CURSOR_NAME D_IDENT;
declare variable L_DETAIL_CURSOR_NAME D_IDENT;
declare variable L_TABLE_DESCRIPTION D_NAME;
declare variable L_WHERE_D varchar(1000);
declare variable L_WHERE_D_ITEM varchar(100);
declare variable L_FIELD_NAME D_IDENT;
declare variable L_FIELD_CAPTION D_NAME;
declare variable L_FIELD_TYPE_D D_IDENT;
declare variable L_FIELD_INDEX integer;
declare variable L_ACTION D_IDENT;
declare variable L_ACTION_ID D_IDENT;
declare variable L_FIELDS varchar(1000);
declare variable L_FIELD_DATAS varchar(1000);
declare variable L_FIELD_PARAMS varchar(1000);
declare variable L_IN_PARAMS varchar(1000);
declare variable L_FIELD_UPDATE varchar(1000);
declare variable L_FIELD_UPDATES varchar(1000);
declare variable L_CRLF varchar(10);
begin
  l_crlf = ascii_char(13) || ascii_char(10);
  l_grid_cursor_name = i_table_name || '_CR';
  l_detail_cursor_name = l_grid_cursor_name || '_D';

  select r.rdb$description
    from rdb$relations r
    where r.rdb$relation_name = :i_table_name
    into :l_table_description;

  -- процедура детали
  insert into ui$block (id, block_type, name, is_modal)
    values (:l_detail_cursor_name, 'procedure', :l_table_description || ' - Детали', 0);
  insert into ui$procedure (id, procedure_name)
    values (:l_detail_cursor_name, :l_detail_cursor_name);
  insert into ui$block_param (block, param, param_direction, data_type, caption, index_in_key, index_in_name)
    select :l_detail_cursor_name, f.field_name, 'field', dt.id, coalesce(f.field_description, f.field_name), f.index_on_key, case when f.field_name = 'NAME' then 1 end
    from ui$get_table_fields(:i_table_name) f
    left join ui$field_type_fb ff on ff.fb_type_id = f.field_type_fb
    left join ui$data_type dt on dt.id = ff.data_type;

  -- заполняем where
  l_field_index = 1;
  l_where_d = 'WHERE' || l_crlf;
  for
    select
      '      T.' || f.field_name || ' = :I_' || f.field_name || ' AND',
      f.field_name, coalesce(f.field_description, f.field_name), f.field_type_name
    from ui$get_table_fields(:i_table_name) f
    where
      f.index_on_key is not null and
      1=1
    order by f.order_num
    into :l_where_d_item, :l_field_name, :l_field_caption, :l_field_type_d
  do
  begin
    l_where_d = l_where_d || l_where_d_item || l_crlf;
    insert into ui$block_param (block, param, param_direction, data_type, order_num, caption, call_order_num)
      values (:l_detail_cursor_name, 'I_' || :l_field_name, 'in', :l_field_type_d, :l_field_index, :l_field_caption, :l_field_index);
    l_field_index = l_field_index + 1;
  end
  l_where_d = l_where_d || '      1=1';

  if (i_include_term = 1) then
    o_script = 'SET TERM ^ ;' || l_crlf;
  else
    o_script = '';

  execute procedure ui$get_table_fields_str(i_table_name, null, 1) returning_values (l_field_datas);
  execute procedure ui$get_table_fields_str(i_table_name, 'T.', 0) returning_values (l_fields);
  execute procedure ui$get_table_fields_str(i_table_name, ':', 0) returning_values (l_field_params);
  execute procedure ui$get_table_fields_str(i_table_name, 'I_', 1, 1) returning_values (l_in_params);

  -- курсор для показа одной записи, для редактирования
  o_script = o_script || 'CREATE OR ALTER PROCEDURE ' || l_detail_cursor_name || l_crlf;
  o_script = o_script || '(' || l_in_params || ') RETURNS (' || l_crlf;
  o_script = o_script || '  ' || l_field_datas || l_crlf;
  o_script = o_script || ') AS BEGIN' || l_crlf;
  o_script = o_script || '  FOR' || l_crlf;
  o_script = o_script || '    SELECT ' || l_fields || l_crlf;
  o_script = o_script || '    FROM ' || i_table_name || ' T ' || l_crlf;
  o_script = o_script || '    ' || l_where_d || l_crlf;
  o_script = o_script || '    INTO ' || l_field_params || l_crlf;
  o_script = o_script || '  DO SUSPEND;' || l_crlf;
  o_script = o_script || 'END^' || l_crlf;

  -- процедура добавления записи
  execute procedure ui$get_table_fields_str(i_table_name, 'I_', 1) returning_values (l_field_datas);
  execute procedure ui$get_table_fields_str(i_table_name, null, 0) returning_values (l_fields);
  execute procedure ui$get_table_fields_str(i_table_name, ':I_', 0) returning_values (l_field_params);

  o_script = o_script || 'CREATE OR ALTER PROCEDURE ' || i_table_name || '_INS' || l_crlf;
  o_script = o_script || '(' || l_field_datas || ')' || l_crlf;
  o_script = o_script || 'AS BEGIN' || l_crlf;
  o_script = o_script || '  INSERT INTO ' || i_table_name || ' (' || l_fields || ')' || l_crlf;
  o_script = o_script || '  VALUES  (' || l_field_params || ');' || l_crlf;
  o_script = o_script || 'END^' || l_crlf;

  -- изменения записи
  l_field_updates = '';
  for
    select 'T.' || f.field_name || '=:I_' || f.field_name f
    from ui$get_table_fields(:i_table_name) f
    where
      f.index_on_key is null and
      1=1
    into :l_field_update
  do
    l_field_updates = l_field_updates || l_field_update || ',';
  l_field_updates = substring(l_field_updates from 1 for char_length(l_field_updates) - 1);
  o_script = o_script || 'CREATE OR ALTER PROCEDURE ' || i_table_name || '_UPD' || l_crlf;
  o_script = o_script || '(' || l_field_datas || ')' || l_crlf;
  o_script = o_script || 'AS BEGIN' || l_crlf;
  o_script = o_script || '  UPDATE ' || i_table_name || ' T' || l_crlf;
  o_script = o_script || '  SET ' || l_field_updates || l_crlf;
  l_field_updates = '';
  for
    select 'T.' || f.field_name || '=:I_' || f.field_name f
    from ui$get_table_fields(:i_table_name) f
    where
      f.index_on_key is not null and
      1=1
    order by f.order_num
    into :l_field_update
  do
    l_field_updates = l_field_updates || l_field_update || ' AND ';
  l_field_updates = l_field_updates || '1=1';
  o_script = o_script || '  WHERE ' || l_field_updates || ';' || l_crlf;
  o_script = o_script || 'END^' || l_crlf;

  -- удаления записи
  o_script = o_script || 'CREATE OR ALTER PROCEDURE ' || i_table_name || '_DEL' || l_crlf;
  o_script = o_script || '(' || l_field_datas || ')' || l_crlf;
  o_script = o_script || 'AS BEGIN' || l_crlf;
  o_script = o_script || '  DELETE FROM ' || i_table_name || ' T' || l_crlf;
  o_script = o_script || '  WHERE ' || l_field_updates || ';' || l_crlf;
  o_script = o_script || 'END^' || l_crlf;

  if (i_include_term = 1) then
    o_script = o_script || 'SET TERM ; ^' || l_crlf;

  -- действия по умолчанию
  for
    select a.id
    from ui$default_action a
    into :l_action
  do
  begin
    execute procedure ui$generate_editor_form (
      i_table_name, l_action
    );

    -- действия в процедуре просмотра
    insert into ui$block_action (
        id, block, caption,
        links_to, action_style,
        image_index, order_num, refresh_mode
      )
      select
        a.id, :l_grid_cursor_name, a.name,
        :i_table_name || '_' || a.name_in_code || '_FR',
        'button',
        a.image_index, a.order_num, a.refresh_mode
      from ui$default_action a
      where a.id = :l_action
      returning id into :l_action_id;

    -- бинды к действию
    insert into ui$action_bind (block, action, param, destination_param)
      select :l_grid_cursor_name, :l_action_id, f.field_name, 'I_' || f.field_name
      from ui$get_table_fields(:i_table_name) f
      where
        f.index_on_key is not null and
        :l_action <> 'insert' and
        1=1;
  end

end^


CREATE OR ALTER PROCEDURE UI$GET_FIELD_TYPE_NAME (
    I_FIELD_NAME VARCHAR(30))
RETURNS (
    TYPE_NAME D_NAME)
AS
  declare variable l_type integer;
  declare variable l_sub_type integer;
  declare variable l_length integer;
  declare variable l_scale integer;
  declare variable l_prec integer;
begin
  select
    f.rdb$field_type,
    f.rdb$field_sub_type,
    -- utf!
    f.rdb$field_length / 4,
    f.rdb$field_scale,
    f.rdb$field_precision
    from rdb$fields f
    where f.rdb$field_name = :i_field_name
    into :l_type, :l_sub_type, :l_length, :l_scale, :l_prec;
  if (l_type = 261) then
    type_name = 'BLOB SUB_TYPE ' || :l_sub_type;
  else if (l_type = 45) then
    type_name = 'BLOB_ID';
  else if (l_type = 17) then
    type_name = 'BOOLEAN';
  else if (l_type = 14) then
    type_name = 'CHAR(' || :l_length || ')';
  else if (l_type = 11) then
    type_name = 'D_FLOAT';
  else if (l_type = 27) then
    type_name = 'DOUBLE';
  else if (l_type = 10) then
    type_name = 'FLOAT';
  else if (l_type = 16) then
    type_name = 'INT64';
  else if (l_type = 8) then
    type_name = 'INTEGER';
  else if (l_type = 9) then
    type_name = 'QUAD';
  else if (l_type = 7) then
    type_name = 'SMALLINT';
  else if (l_type = 12) then
    type_name = 'DATE';
  else if (l_type = 13) then
    type_name = 'TIME';
  else if (l_type = 35) then
    type_name = 'TIMESTAMP';
  else if (l_type = 37) then
    type_name = 'VARCHAR(' || :l_length || ')';
  suspend;
end^


CREATE OR ALTER PROCEDURE UI$GET_TABLE_FIELDS (
    I_TABLE_NAME D_IDENT)
RETURNS (
    FIELD_NAME D_IDENT,
    FIELD_TYPE D_NAME,
    FIELD_DESCRIPTION VARCHAR(1000),
    FIELD_TYPE_FB INTEGER,
    FIELD_TYPE_NAME D_IDENT,
    INDEX_ON_KEY INTEGER,
    ORDER_NUM SMALLINT)
AS
begin
  for
    select
      trim(f.rdb$field_name),
      trim(t.type_name),
      trim(f.rdb$description),
      trim(ff.rdb$field_type),
      dt.id,
      pf.rdb$field_position + 1,
      f.rdb$field_position
    from rdb$relation_fields f
    join rdb$fields ff on ff.rdb$field_name = f.rdb$field_source
    join rdb$relation_constraints pc on pc.rdb$relation_name = f.rdb$relation_name and pc.rdb$constraint_type = 'PRIMARY KEY'
    left join rdb$index_segments pf on pf.rdb$index_name = pc.rdb$index_name and pf.rdb$field_name = f.rdb$field_name
    left join ui$get_field_type_name(f.rdb$field_source) t on 1=1
    left join ui$field_type_fb ft on ft.fb_type_id = ff.rdb$field_type
    left join ui$data_type dt on dt.id = ft.data_type
    where
      f.rdb$relation_name = :i_table_name and
      1=1
    order by f.rdb$field_position
    into
      :field_name, :field_type, :field_description,
      :field_type_fb, :field_type_name, :index_on_key, :order_num
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE UI$GET_TABLE_FIELDS_STR (
    I_TABLE_NAME D_IDENT,
    I_FIELD_PREFIX VARCHAR(10),
    I_ADD_DATA_TYPE D_BOOLEAN,
    I_KEY_ONLY D_BOOLEAN = 0)
RETURNS (
    O_FIELDS VARCHAR(1000))
AS
  declare variable l_field varchar(1000);
  declare variable l_index_on_key smallint;
begin
  o_fields = '';
  for
    select
      case
        when :i_field_prefix is not null then :i_field_prefix || f.field_name
        else f.field_name
      end ||
      case
        when :i_add_data_type = 1 then ' ' || f.field_type
        else ''
      end,
      f.index_on_key
    from ui$get_table_fields(:i_table_name) f
    order by f.order_num
    into :l_field, :l_index_on_key
  do
    if (i_key_only = 0 or l_index_on_key is not null) then
      o_fields = o_fields || l_field ||  ',';
  if (o_fields <> '') then
    o_fields = substring(o_fields from 1 for char_length(o_fields) - 1);
end^


CREATE OR ALTER PROCEDURE UI$GET_TABLE_LINKS (
    I_TABLE_NAME D_IDENT)
RETURNS (
    FK_NAME D_IDENT,
    LINKS_TO_TABLE D_IDENT,
    LINKS_TO_PROCEDURE D_IDENT,
    FIELD_NAME D_IDENT,
    LINKS_TO_FIELD D_IDENT,
    FIELD_POSITION SMALLINT,
    LINK_INDEX SMALLINT)
AS
  declare variable l_last_fk_name d_ident;
begin
  link_index = 0;
  l_last_fk_name = '';
  for
    select
      trim(c.rdb$constraint_name),
      trim(cc.rdb$relation_name),
      p.id,
      trim(f.rdb$field_name),
      trim(lf.rdb$field_name),
      f.rdb$field_position + 1
    from rdb$relation_constraints c
    join rdb$ref_constraints rc on rc.rdb$constraint_name = c.rdb$constraint_name
    join rdb$relation_constraints cc on cc.rdb$constraint_name = rc.rdb$const_name_uq
    left join ui$procedure p on p.is_grid_for_table = cc.rdb$relation_name
    join rdb$index_segments f on f.rdb$index_name = c.rdb$index_name
    join rdb$index_segments lf on lf.rdb$index_name = rc.rdb$const_name_uq and lf.rdb$field_position = f.rdb$field_position
    where
      c.rdb$constraint_type = 'FOREIGN KEY' and
      c.rdb$relation_name = :i_table_name and
      1=1
    order by c.rdb$constraint_name, lf.rdb$field_position
    into :fk_name, :links_to_table, :links_to_procedure, :field_name, :links_to_field, :field_position
  do
  begin
    if (fk_name <> l_last_fk_name) then
    begin
      link_index = link_index + 1;
      l_last_fk_name = fk_name;
    end
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE UI$GRID_STYLE_CR (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100))
AS
 BEGIN
  FOR
    SELECT T.ID,T.NAME
    FROM UI$GRID_STYLE T     
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      1=1
    INTO :ID,:NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$MENU_ITEM_CR (
    I_ID INTEGER = null,
    I_PARENT INTEGER = null,
    I_FND D_NAME = null)
RETURNS (
    ID INTEGER,
    NAME VARCHAR(100),
    ITEM_TYPE VARCHAR(30),
    PARENT INTEGER,
    "BLOCK" VARCHAR(30),
    ORDER_NUM INTEGER,
    L_PARENT_NAME VARCHAR(100),
    L_ITEM_TYPE_NAME VARCHAR(100))
AS
BEGIN
  FOR
    SELECT
      T.ID,T.NAME,T.ITEM_TYPE,T.PARENT,T."BLOCK",T.ORDER_NUM,
      L_2.NAME AS L_PARENT_NAME,L_1.NAME AS L_ITEM_TYPE_NAME
    FROM UI$MENU_ITEM T 
    LEFT JOIN CR_UI$MENU_ITEM_TYPE(T.ITEM_TYPE) L_1 ON 1=1
    LEFT JOIN UI$MENU_ITEM L_2 ON L_2.ID = T.PARENT
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      (:I_PARENT IS NULL OR T.PARENT = :I_PARENT) AND
      (:I_FND IS NULL OR LOWER(T.NAME) LIKE '%' || :I_FND || '%') AND
      1=1
    ORDER BY T.PARENT, T.ORDER_NUM
    INTO :ID,:NAME,:ITEM_TYPE,:PARENT,:"BLOCK",:ORDER_NUM,:L_PARENT_NAME,:L_ITEM_TYPE_NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$MENU_ITEM_CR_D (
    I_ID INTEGER)
RETURNS (
    ID INTEGER,
    NAME VARCHAR(100),
    ITEM_TYPE VARCHAR(30),
    PARENT INTEGER,
    "BLOCK" VARCHAR(30),
    ORDER_NUM INTEGER)
AS
 BEGIN
  FOR
    SELECT T.ID,T.NAME,T.ITEM_TYPE,T.PARENT,T.BLOCK,T.ORDER_NUM
    FROM UI$MENU_ITEM T 
    WHERE
      T.ID = :I_ID AND
      1=1
    INTO :ID,:NAME,:ITEM_TYPE,:PARENT,:BLOCK,:ORDER_NUM
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$MENU_ITEM_DEL (
    I_ID INTEGER,
    I_NAME VARCHAR(100),
    I_ITEM_TYPE VARCHAR(30),
    I_PARENT INTEGER,
    I_BLOCK VARCHAR(30),
    I_ORDER_NUM INTEGER)
AS
 BEGIN
  DELETE FROM UI$MENU_ITEM T
  WHERE T.ID=:I_ID AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$MENU_ITEM_INS (
    I_ID INTEGER,
    I_NAME VARCHAR(100),
    I_ITEM_TYPE VARCHAR(30),
    I_PARENT INTEGER,
    I_BLOCK VARCHAR(30),
    I_ORDER_NUM INTEGER)
AS
 BEGIN
  INSERT INTO UI$MENU_ITEM (ID,NAME,ITEM_TYPE,PARENT,BLOCK,ORDER_NUM)
  VALUES  (:I_ID,:I_NAME,:I_ITEM_TYPE,:I_PARENT,:I_BLOCK,:I_ORDER_NUM);
END^


CREATE OR ALTER PROCEDURE UI$MENU_ITEM_UPD (
    I_ID INTEGER,
    I_NAME VARCHAR(100),
    I_ITEM_TYPE VARCHAR(30),
    I_PARENT INTEGER,
    I_BLOCK VARCHAR(30),
    I_ORDER_NUM INTEGER)
AS
 BEGIN
  UPDATE UI$MENU_ITEM T
  SET T.NAME=:I_NAME,T.ITEM_TYPE=:I_ITEM_TYPE,T.PARENT=:I_PARENT,T.BLOCK=:I_BLOCK,T.ORDER_NUM=:I_ORDER_NUM
  WHERE T.ID=:I_ID AND 1=1;
END^


CREATE OR ALTER PROCEDURE UI$PANEL_ALIGN_CR (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100))
AS
 BEGIN
  FOR
    SELECT T.ID,T.NAME
    FROM UI$PANEL_ALIGN T     
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      1=1
    INTO :ID,:NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$PARAM_ALIGN_CR (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100))
AS
 BEGIN
  FOR
    SELECT T.ID,T.NAME
    FROM UI$PARAM_ALIGN T     
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      1=1
    INTO :ID,:NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$PARAM_DIRECTION_CR (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100))
AS
 BEGIN
  FOR
    SELECT T.ID,T.NAME
    FROM UI$PARAM_DIRECTION T     
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      1=1
    INTO :ID,:NAME
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$PROCEDURE_CR (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100),
    CUSTOM_CLASS VARCHAR(100),
    PROCEDURE_NAME VARCHAR(30),
    IS_GRID_FOR_TABLE VARCHAR(30),
    IS_MODAL SMALLINT)
AS
 BEGIN
  FOR
    SELECT T.ID,T.PROCEDURE_NAME,T.IS_GRID_FOR_TABLE,B.NAME,B.CUSTOM_CLASS,B.IS_MODAL
    FROM UI$PROCEDURE T
    JOIN UI$BLOCK B ON B.ID = T.ID
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      1=1
    ORDER BY T.ID
    INTO :ID,:PROCEDURE_NAME,:IS_GRID_FOR_TABLE,:NAME,:CUSTOM_CLASS,:IS_MODAL
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$PROCEDURE_CR_D (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100),
    CUSTOM_CLASS VARCHAR(100),
    PROCEDURE_NAME VARCHAR(30),
    IS_GRID_FOR_TABLE VARCHAR(30),
    IS_MODAL SMALLINT)
AS
 BEGIN
  FOR
    SELECT T.ID,T.PROCEDURE_NAME,T.IS_GRID_FOR_TABLE,B.NAME,B.CUSTOM_CLASS,B.IS_MODAL
    FROM UI$PROCEDURE T
    JOIN UI$BLOCK B ON B.ID = T.ID
    WHERE
      T.ID = :I_ID AND
      1=1
    INTO :ID,:PROCEDURE_NAME,:IS_GRID_FOR_TABLE,:NAME,:CUSTOM_CLASS,:IS_MODAL
  DO SUSPEND;
END^


CREATE OR ALTER PROCEDURE UI$PROCEDURE_DEL (
    I_ID VARCHAR(30))
AS
BEGIN
  delete from ui$block b
  where b.id= :i_id;
END^


CREATE OR ALTER PROCEDURE UI$PROCEDURE_INS (
    I_ID VARCHAR(30),
    I_NAME VARCHAR(100),
    I_CUSTOM_CLASS VARCHAR(100),
    I_PROCEDURE_NAME VARCHAR(30),
    I_IS_GRID_FOR_TABLE VARCHAR(30),
    I_IS_MODAL SMALLINT)
AS
BEGIN
  INSERT INTO UI$BLOCK (ID,BLOCK_TYPE, NAME, CUSTOM_CLASS, IS_MODAL)
  VALUES  (:I_ID,'procedure',:I_NAME, :I_CUSTOM_CLASS, :I_IS_MODAL);

  INSERT INTO UI$PROCEDURE (ID,PROCEDURE_NAME,IS_GRID_FOR_TABLE)
  VALUES  (:I_ID,:I_PROCEDURE_NAME,:I_IS_GRID_FOR_TABLE);
END^


CREATE OR ALTER PROCEDURE UI$PROCEDURE_UPD (
    I_ID VARCHAR(30),
    I_NAME VARCHAR(100),
    I_CUSTOM_CLASS VARCHAR(100),
    I_PROCEDURE_NAME VARCHAR(30),
    I_IS_GRID_FOR_TABLE VARCHAR(30),
    I_IS_MODAL SMALLINT)
AS
begin
  update ui$procedure t
  set t.procedure_name=:i_procedure_name,t.is_grid_for_table=:i_is_grid_for_table
  where t.id=:i_id and 1=1;

  update ui$block b
    set
      b.name = :i_name,
      b.custom_class = :i_custom_class,
      b.is_modal = :i_is_modal
    where
      b.id = :i_id;
end^


CREATE OR ALTER PROCEDURE UI$REFRESH_MODE_CR (
    I_ID VARCHAR(30))
RETURNS (
    ID VARCHAR(30),
    NAME VARCHAR(100))
AS
 BEGIN
  FOR
    SELECT T.ID,T.NAME
    FROM UI$REFRESH_MODE T     
    WHERE
      (T.ID = :I_ID OR :I_ID IS NULL) AND
      1=1
    INTO :ID,:NAME
  DO SUSPEND;
END^



SET TERM ; ^


/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

COMMENT ON TABLE UI$ACTION_BIND IS 
'Бинды действия от блока к блоку';

COMMENT ON TABLE UI$ACTION_STYLE IS 
'Стиль действия';

COMMENT ON TABLE UI$BLOCK IS 
'Абстрактные блоки интерфейса';

COMMENT ON TABLE UI$BLOCK_ACTION IS 
'Действия в блоке';

COMMENT ON TABLE UI$BLOCK_PARAM IS 
'Параметры блока';

COMMENT ON TABLE UI$BLOCK_REF IS 
'Ссылки в параметрах блоков';

COMMENT ON TABLE UI$BLOCK_REF_BIND IS 
'Параметры вызова процедур для внешних ключей';

COMMENT ON TABLE UI$BLOCK_REF_PARAM IS 
'Параметры в ссылках блока';

COMMENT ON TABLE UI$BLOCK_TYPE IS 
'Типы блоков';

COMMENT ON TABLE UI$DATA_TYPE IS 
'Простые типы данных';

COMMENT ON TABLE UI$FORM IS 
'Форма - готовый блок интерфейса';

COMMENT ON TABLE UI$FORM_CHILD IS 
'Блоки в форме';

COMMENT ON TABLE UI$FORM_CHILD_PARAM IS 
'Параметры в блоках формы';

COMMENT ON TABLE UI$FORM_CHILD_REF_BIND IS 
'Параметры ссылок в форме';

COMMENT ON TABLE UI$FORM_PANEL IS 
'Панели на форме';

COMMENT ON TABLE UI$GRID_STYLE IS 
'Вид показа грида';

COMMENT ON TABLE UI$MENU_ITEM IS 
'Пункты меню';

COMMENT ON TABLE UI$MENU_ITEM_TYPE IS 
'Тип пункта главного меню';

COMMENT ON TABLE UI$PANEL_ALIGN IS 
'Тип выравнивания в панели';

COMMENT ON TABLE UI$PARAM_ALIGN IS 
'Расположение показа параметров
horizontal,vertical';

COMMENT ON TABLE UI$PARAM_DIRECTION IS 
'Типы параметров
in,out,inout,field';

COMMENT ON TABLE UI$PROCEDURE IS 
'Вызов процедуры - абстрактный блок интерфейса';

COMMENT ON TABLE UI$REFRESH_MODE IS 
'Способ обновления после действия';



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

COMMENT ON PROCEDURE CR_UI$MENU IS 
'Меню приложения';

COMMENT ON PROCEDURE UI$GENERATE_FORM_BY_TABLE IS 
'Создать процедуры и описание интерфейса таблицы';

COMMENT ON PROCEDURE UI$MENU_ITEM_CR IS 
'Пункты меню';



/******************************************************************************/
/***                          Fields descriptions                           ***/
/******************************************************************************/

COMMENT ON COLUMN UI$ACTION_BIND."BLOCK" IS 
'Блок';

COMMENT ON COLUMN UI$ACTION_BIND."ACTION" IS 
'Действие';

COMMENT ON COLUMN UI$ACTION_BIND.PARAM IS 
'Параметр';

COMMENT ON COLUMN UI$ACTION_BIND.DESTINATION_PARAM IS 
'Параметр-назначение';

COMMENT ON COLUMN UI$ACTION_STYLE.NAME IS 
'Название';

COMMENT ON COLUMN UI$BLOCK_ACTION."BLOCK" IS 
'Блок';

COMMENT ON COLUMN UI$BLOCK_ACTION.CAPTION IS 
'Название';

COMMENT ON COLUMN UI$BLOCK_ACTION.LINKS_TO IS 
'Ссылка на блок';

COMMENT ON COLUMN UI$BLOCK_ACTION.ACTION_STYLE IS 
'Тип ссылки';

COMMENT ON COLUMN UI$BLOCK_ACTION.IMAGE_INDEX IS 
'Номер картинки';

COMMENT ON COLUMN UI$BLOCK_ACTION.ORDER_NUM IS 
'Порядковый номер';

COMMENT ON COLUMN UI$BLOCK_ACTION.REFRESH_MODE IS 
'Способ обновления после вызова';

COMMENT ON COLUMN UI$BLOCK_PARAM."BLOCK" IS 
'Блок';

COMMENT ON COLUMN UI$BLOCK_PARAM.PARAM IS 
'Параметр';

COMMENT ON COLUMN UI$BLOCK_PARAM.PARAM_DIRECTION IS 
'Тип параметра';

COMMENT ON COLUMN UI$BLOCK_PARAM.DATA_TYPE IS 
'Тип данных';

COMMENT ON COLUMN UI$BLOCK_PARAM.CAPTION IS 
'Название';

COMMENT ON COLUMN UI$BLOCK_PARAM.ORDER_NUM IS 
'Порядковый номер';

COMMENT ON COLUMN UI$BLOCK_PARAM.VISIBLE IS 
'Видимость';

COMMENT ON COLUMN UI$BLOCK_PARAM.REQUIRED IS 
'Обязательность';

COMMENT ON COLUMN UI$BLOCK_PARAM.GROUP_NAME IS 
'Группа параметров';

COMMENT ON COLUMN UI$BLOCK_PARAM.ENABLER_PARAM IS 
'Параметр-включатель';

COMMENT ON COLUMN UI$BLOCK_PARAM.SOURCE_CHILD IS 
'Источник, блок в форме, для ссылок из формы';

COMMENT ON COLUMN UI$BLOCK_PARAM.SOURCE_PARAM IS 
'Источник, параметр';

COMMENT ON COLUMN UI$BLOCK_PARAM.INDEX_IN_KEY IS 
'Индекс в ключе';

COMMENT ON COLUMN UI$BLOCK_PARAM.INDEX_IN_PARENT IS 
'Индекс в полях-предках, для дерева';

COMMENT ON COLUMN UI$BLOCK_PARAM.INDEX_IN_NAME IS 
'Индекс в имени';

COMMENT ON COLUMN UI$BLOCK_PARAM.READ_ONLY IS 
'Только для чтения';

COMMENT ON COLUMN UI$BLOCK_PARAM.CALL_ORDER_NUM IS 
'Порядковый номер в вызове процедуры';

COMMENT ON COLUMN UI$BLOCK_REF.ID IS 
'Код записи';

COMMENT ON COLUMN UI$BLOCK_REF."BLOCK" IS 
'Блок, откуда ссылка';

COMMENT ON COLUMN UI$BLOCK_REF.REFS_TO IS 
'Блок, куда ссылка';

COMMENT ON COLUMN UI$BLOCK_REF_BIND.REF IS 
'Код ссылки';

COMMENT ON COLUMN UI$BLOCK_REF_BIND."BLOCK" IS 
'Блок ссылки';

COMMENT ON COLUMN UI$BLOCK_REF_BIND.DESTINATION_PARAM IS 
'В какой параметр';

COMMENT ON COLUMN UI$BLOCK_REF_BIND.SOURCE_PARAM IS 
'Из какого параметра';

COMMENT ON COLUMN UI$BLOCK_REF_PARAM.REF IS 
'Код ссылки';

COMMENT ON COLUMN UI$BLOCK_REF_PARAM."BLOCK" IS 
'Блок ссылки';

COMMENT ON COLUMN UI$BLOCK_REF_PARAM.PARAM IS 
'Параметр в ссылке';

COMMENT ON COLUMN UI$BLOCK_REF_PARAM.ORDER_NUM IS 
'Порядковый номер параметра';

COMMENT ON COLUMN UI$BLOCK_REF_PARAM.IS_MAIN_PARAM IS 
'Главный параметр, в его редакторе будет ссылка';

COMMENT ON COLUMN UI$BLOCK_TYPE.NAME IS 
'Название';

COMMENT ON COLUMN UI$DATA_TYPE.ID IS 
'Код записи';

COMMENT ON COLUMN UI$DATA_TYPE.NAME IS 
'Название';

COMMENT ON COLUMN UI$FORM.HEADER_VISIBLE IS 
'Показывать заголовок';

COMMENT ON COLUMN UI$FORM_CHILD.ID IS 
'Код записи';

COMMENT ON COLUMN UI$FORM_CHILD.FORM IS 
'Форма';

COMMENT ON COLUMN UI$FORM_CHILD.PANEL IS 
'На какой панели';

COMMENT ON COLUMN UI$FORM_CHILD."BLOCK" IS 
'Блок';

COMMENT ON COLUMN UI$FORM_CHILD.VISIBLE IS 
'Видимость';

COMMENT ON COLUMN UI$FORM_CHILD.ORDER_NUM IS 
'Порядковый номер расположения на панели';

COMMENT ON COLUMN UI$FORM_CHILD.PARAM_GROUP_ALIGN IS 
'Направление отрисовки групп параметров';

COMMENT ON COLUMN UI$FORM_CHILD.PARAM_ALIGN IS 
'Направление отрисовки параметров';

COMMENT ON COLUMN UI$FORM_CHILD_PARAM.FORM_CHILD IS 
'Блок формы';

COMMENT ON COLUMN UI$FORM_CHILD_PARAM.PARAM IS 
'Параметр';

COMMENT ON COLUMN UI$FORM_CHILD_PARAM.FORM IS 
'Форма блока';

COMMENT ON COLUMN UI$FORM_CHILD_PARAM."BLOCK" IS 
'Блок';

COMMENT ON COLUMN UI$FORM_CHILD_PARAM.VISIBLE IS 
'Видимость';

COMMENT ON COLUMN UI$FORM_CHILD_PARAM.REQUIRED IS 
'Обязательность';

COMMENT ON COLUMN UI$FORM_CHILD_PARAM.READ_ONLY IS 
'Только чтение';

COMMENT ON COLUMN UI$FORM_CHILD_PARAM.SOURCE_BLOCK IS 
'Блок-источник';

COMMENT ON COLUMN UI$FORM_CHILD_PARAM.SOURCE_CHILD IS 
'Блок-источник';

COMMENT ON COLUMN UI$FORM_CHILD_PARAM.SOURCE_PARAM IS 
'Параметр-источник';

COMMENT ON COLUMN UI$FORM_CHILD_PARAM.AUTO_REFRESH IS 
'Автоматическое обновление';

COMMENT ON COLUMN UI$FORM_CHILD_REF_BIND.FORM_CHILD IS 
'Блок';

COMMENT ON COLUMN UI$FORM_CHILD_REF_BIND.FORM IS 
'Форма';

COMMENT ON COLUMN UI$FORM_CHILD_REF_BIND."BLOCK" IS 
'Блок';

COMMENT ON COLUMN UI$FORM_CHILD_REF_BIND.REF IS 
'Ссылка';

COMMENT ON COLUMN UI$FORM_CHILD_REF_BIND.DESTINATION_PARAM IS 
'Параметр-назначение';

COMMENT ON COLUMN UI$FORM_CHILD_REF_BIND.SOURCE_CHILD IS 
'Блок-источник';

COMMENT ON COLUMN UI$FORM_CHILD_REF_BIND.SOURCE_BLOCK IS 
'Блок-источник';

COMMENT ON COLUMN UI$FORM_CHILD_REF_BIND.SOURCE_PARAM IS 
'Параметр-источник';

COMMENT ON COLUMN UI$GRID_STYLE.NAME IS 
'Название';

COMMENT ON COLUMN UI$MENU_ITEM.ID IS 
'Код записи';

COMMENT ON COLUMN UI$MENU_ITEM.NAME IS 
'Название';

COMMENT ON COLUMN UI$MENU_ITEM.ITEM_TYPE IS 
'Тип пункта';

COMMENT ON COLUMN UI$MENU_ITEM.PARENT IS 
'Папка';

COMMENT ON COLUMN UI$MENU_ITEM."BLOCK" IS 
'Вызываемый блок';

COMMENT ON COLUMN UI$MENU_ITEM.ORDER_NUM IS 
'Порядковый номер';

COMMENT ON COLUMN UI$MENU_ITEM_TYPE.ID IS 
'Код';

COMMENT ON COLUMN UI$MENU_ITEM_TYPE.NAME IS 
'Название';

COMMENT ON COLUMN UI$PANEL_ALIGN.NAME IS 
'Название';

COMMENT ON COLUMN UI$PARAM_DIRECTION.ID IS 
'in,out,inout,field';

COMMENT ON COLUMN UI$PROCEDURE.IS_GRID_FOR_TABLE IS 
'Для какой таблицы это грид показа';

COMMENT ON COLUMN UI$REFRESH_MODE.ID IS 
'Код';

COMMENT ON COLUMN UI$REFRESH_MODE.NAME IS 
'Название';



/******************************************************************************/
/***                        Parameters descriptions                         ***/
/******************************************************************************/

COMMENT ON PARAMETER CR_UI$MENU.ID IS 
'Код';

COMMENT ON PARAMETER CR_UI$MENU.ITEM_TYPE IS 
'Тип пункта меню';

COMMENT ON PARAMETER CR_UI$MENU.NAME IS 
'Название';

COMMENT ON PARAMETER CR_UI$MENU.ORDER_NUM IS 
'Порядковый номер в папке';

COMMENT ON PARAMETER CR_UI$MENU.PARENT IS 
'Папка';

COMMENT ON PARAMETER UI$GENERATE_FORM_BY_TABLE.I_GENERATE_EDITORS IS 
'Создавать формы редактирования';

COMMENT ON PARAMETER UI$GENERATE_FORM_BY_TABLE.I_GENERATE_FORM IS 
'Создавать форму (к процедуре) просмотра';

COMMENT ON PARAMETER UI$GENERATE_FORM_BY_TABLE.I_MENU_ITEM_PARENT IS 
'В какую папку меню помещать';

COMMENT ON PARAMETER UI$GENERATE_FORM_BY_TABLE.I_TABLE_NAME IS 
'Таблица';

